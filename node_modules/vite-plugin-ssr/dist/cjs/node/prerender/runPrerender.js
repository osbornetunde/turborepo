"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runPrerenderForceExit = exports.runPrerender = void 0;
require("../runtime/page-files/setup");
const path_1 = __importDefault(require("path"));
const route_1 = require("../../shared/route");
const utils_1 = require("./utils");
const pLimit_1 = require("../../utils/pLimit");
const renderPageContext_1 = require("../runtime/renderPage/renderPageContext");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const os_1 = require("os");
const globalContext_1 = require("../runtime/globalContext");
const vite_1 = require("vite");
const getConfigVps_1 = require("../shared/getConfigVps");
const getPageFiles_1 = require("../../shared/getPageFiles");
const getPageContextRequestUrl_1 = require("../../shared/getPageContextRequestUrl");
const resolveRouteString_1 = require("../../shared/route/resolveRouteString");
const utils_2 = require("../../shared/page-configs/utils");
const loadPageCode_1 = require("../../shared/page-configs/loadPageCode");
const error_page_1 = require("../../shared/error-page");
const addComputedUrlProps_1 = require("../../shared/addComputedUrlProps");
async function runPrerender(options, manuallyTriggeredBy) {
    checkOutdatedOptions(options);
    const logLevel = !!options.onPagePrerender ? 'warn' : 'info';
    if (logLevel === 'info') {
        console.log(`${picocolors_1.default.cyan(`vite-plugin-ssr v${utils_1.projectInfo.projectVersion}`)} ${picocolors_1.default.green('pre-rendering HTML...')}`);
    }
    (0, utils_1.setNodeEnvToProduction)();
    disableReactStreaming();
    const viteConfig = await (0, vite_1.resolveConfig)(options.viteConfig || {}, 'vite-plugin-ssr pre-rendering', 'production');
    assertLoadedConfig(viteConfig, options);
    const configVps = await (0, getConfigVps_1.getConfigVps)(viteConfig);
    const { outDirClient } = (0, utils_1.getOutDirs_prerender)(viteConfig);
    const { root } = viteConfig;
    const prerenderConfig = configVps.prerender;
    if (!prerenderConfig) {
        (0, utils_1.assert)(manuallyTriggeredBy);
        (0, utils_1.assertWarning)(prerenderConfig, `You're executing \`${manuallyTriggeredBy}\` but the config \`prerender\` isn't set to true`, {
            onlyOnce: true,
            showStackTrace: false
        });
    }
    const { partial = false, noExtraDir = false, parallel = true } = prerenderConfig || {};
    const concurrencyLimit = (0, pLimit_1.pLimit)(parallel === false || parallel === 0 ? 1 : parallel === true || parallel === undefined ? (0, os_1.cpus)().length : parallel);
    await (0, globalContext_1.initGlobalContext)({ isPrerendering: true });
    const renderContext = await (0, renderPageContext_1.getRenderContext)();
    renderContext.pageFilesAll.forEach(assertExportNames);
    const prerenderContext = {};
    (0, utils_1.objectAssign)(prerenderContext, {
        _urlHandler: null,
        _noExtraDir: noExtraDir ?? false,
        pageContexts: [],
        pageContextInit: options.pageContextInit ?? null
    });
    const doNotPrerenderList = [];
    await collectDoNoPrerenderList(renderContext, doNotPrerenderList, concurrencyLimit);
    await callOnBeforePrerenderStartHooks(prerenderContext, renderContext, concurrencyLimit);
    await handlePagesWithStaticRoutes(prerenderContext, renderContext, doNotPrerenderList, concurrencyLimit);
    await callOnPrerenderStartHook(prerenderContext, renderContext);
    const prerenderPageIds = {};
    const htmlFiles = [];
    await routeAndPrerender(prerenderContext, htmlFiles, prerenderPageIds, concurrencyLimit);
    warnContradictoryNoPrerenderList(prerenderPageIds, doNotPrerenderList);
    await prerender404(htmlFiles, renderContext, prerenderContext);
    if (logLevel === 'info') {
        console.log(`${picocolors_1.default.green(`âœ“`)} ${htmlFiles.length} HTML documents pre-rendered.`);
    }
    await Promise.all(htmlFiles.map((htmlFile) => writeHtmlFile(htmlFile, root, outDirClient, concurrencyLimit, options.onPagePrerender, logLevel)));
    warnMissingPages(prerenderPageIds, doNotPrerenderList, renderContext, partial);
}
exports.runPrerender = runPrerender;
async function collectDoNoPrerenderList(renderContext, doNotPrerenderList, concurrencyLimit) {
    renderContext.pageConfigs.forEach((pageConfig) => {
        const prerenderConfigValue = (0, utils_2.getConfigValue)(pageConfig, 'prerender', 'boolean');
        if (prerenderConfigValue === false) {
            const configElement = pageConfig.configElements.prerender;
            (0, utils_1.assert)(configElement);
            (0, utils_1.assert)(configElement.configValue === false);
            doNotPrerenderList.push({
                pageId: pageConfig.pageId,
                setByConfigName: 'prerender',
                setByConfigValue: false,
                setByConfigFile: configElement.configDefinedByFile
            });
        }
    });
    await Promise.all(renderContext.pageFilesAll
        .filter((p) => {
        assertExportNames(p);
        if (!p.exportNames?.includes('doNotPrerender'))
            return false;
        (0, utils_1.assertUsage)(p.fileType !== '.page.client', `${p.filePath} (which is a \`.page.client.js\` file) has \`export { doNotPrerender }\` but it is only allowed in \`.page.server.js\` or \`.page.js\` files`);
        return true;
    })
        .map((p) => concurrencyLimit(async () => {
        (0, utils_1.assert)(p.loadFile);
        await p.loadFile();
    })));
    renderContext.allPageIds.forEach((pageId) => {
        const pageFilesServerSide = (0, getPageFiles_1.getPageFilesServerSide)(renderContext.pageFilesAll, pageId);
        for (const p of pageFilesServerSide) {
            if (!p.exportNames?.includes('doNotPrerender'))
                continue;
            const { fileExports } = p;
            (0, utils_1.assert)(fileExports);
            (0, utils_1.assert)((0, utils_1.hasProp)(fileExports, 'doNotPrerender'));
            const { doNotPrerender } = fileExports;
            (0, utils_1.assertUsage)(doNotPrerender === true || doNotPrerender === false, `The \`export { doNotPrerender }\` value of ${p.filePath} should be \`true\` or \`false\``);
            if (!doNotPrerender) {
                // Do pre-render `pageId`
                return;
            }
            else {
                // Don't pre-render `pageId`
                doNotPrerenderList.push({
                    pageId,
                    setByConfigFile: p.filePath,
                    setByConfigName: 'doNotPrerender',
                    setByConfigValue: doNotPrerender
                });
            }
        }
    });
}
function assertExportNames(pageFile) {
    const { exportNames, fileType } = pageFile;
    (0, utils_1.assert)(exportNames || fileType === '.page.route' || fileType === '.css', pageFile.filePath);
}
async function callOnBeforePrerenderStartHooks(prerenderContext, renderContext, concurrencyLimit) {
    const onBeforePrerenderStartHooks = [];
    // V1 design
    await Promise.all(renderContext.pageConfigs.map((pageConfig) => concurrencyLimit(async () => {
        if (!pageConfig.configElements.onBeforePrerenderStart)
            return;
        const codeFilePath = (0, utils_2.getCodeFilePath)(pageConfig, 'onBeforePrerenderStart');
        (0, utils_1.assert)(codeFilePath);
        const pageConfigLoaded = await (0, loadPageCode_1.loadPageCode)(pageConfig, false);
        const hookFn = pageConfigLoaded.configValues.onBeforePrerenderStart;
        (0, utils_1.assert)(hookFn);
        (0, utils_1.assertUsage)((0, utils_1.isCallable)(hookFn), `The onBeforePrerenderStart() hook defined by ${codeFilePath} should be a function`);
        onBeforePrerenderStartHooks.push({
            hookFn,
            hookName: 'onBeforePrerenderStart',
            hookFilePath: codeFilePath
        });
    })));
    // 0.4 design
    await Promise.all(renderContext.pageFilesAll
        .filter((p) => {
        assertExportNames(p);
        if (!p.exportNames?.includes('prerender'))
            return false;
        (0, utils_1.assertUsage)(p.fileType === '.page.server', `${p.filePath} (which is a \`${p.fileType}.js\` file) has \`export { prerender }\` but it is only allowed in \`.page.server.js\` files`);
        return true;
    })
        .map((p) => concurrencyLimit(async () => {
        await p.loadFile?.();
        const hookFn = p.fileExports?.prerender;
        if (!hookFn)
            return;
        (0, utils_1.assertUsage)((0, utils_1.isCallable)(hookFn), `\`export { prerender }\` of ${p.filePath} should be a function.`);
        const hookFilePath = p.filePath;
        (0, utils_1.assert)(hookFilePath);
        onBeforePrerenderStartHooks.push({
            hookFn,
            hookName: 'prerender',
            hookFilePath
        });
    })));
    await Promise.all(onBeforePrerenderStartHooks.map(({ hookFn, hookName, hookFilePath }) => concurrencyLimit(async () => {
        const prerenderResult = await hookFn();
        const result = normalizeOnPrerenderHookResult(prerenderResult, hookFilePath, hookName);
        result.forEach(({ url, pageContext }) => {
            {
                const pageContextFound = prerenderContext.pageContexts.find((pageContext) => isSameUrl(pageContext.urlOriginal, url));
                if (pageContextFound) {
                    (0, utils_1.assert)(pageContextFound._providedByHook);
                    const providedTwice = hookFilePath === pageContextFound._providedByHook.hookFilePath
                        ? `twice by the ${hookName}() hook (${hookFilePath})`
                        : `twice: by the ${hookName}() hook (${hookFilePath}) as well as by the hook ${pageContextFound._providedByHook.hookFilePath}() (${pageContextFound._providedByHook.hookName})`;
                    (0, utils_1.assertUsage)(false, `URL '${url}' provided ${providedTwice}. Make sure to provide the URL only once instead.`);
                }
            }
            const pageContextNew = createPageContext(url, renderContext, prerenderContext);
            (0, utils_1.objectAssign)(pageContextNew, {
                _providedByHook: {
                    hookFilePath,
                    hookName
                }
            });
            prerenderContext.pageContexts.push(pageContextNew);
            if (pageContext) {
                (0, utils_1.objectAssign)(pageContextNew, {
                    _pageContextAlreadyProvidedByOnPrerenderHook: true,
                    ...pageContext
                });
            }
        });
    })));
}
async function handlePagesWithStaticRoutes(prerenderContext, renderContext, doNotPrerenderList, concurrencyLimit) {
    // Pre-render pages with a static route
    const { pageRoutes } = await (0, route_1.loadPageRoutes)(renderContext.pageFilesAll, renderContext.pageConfigs, renderContext.pageConfigGlobal, renderContext.allPageIds);
    await Promise.all(pageRoutes.map((pageRoute) => concurrencyLimit(async () => {
        const { pageId } = pageRoute;
        if (doNotPrerenderList.find((p) => p.pageId === pageId)) {
            return;
        }
        let urlOriginal;
        if (!('routeString' in pageRoute)) {
            // Abort since the page's route is a Route Function
            (0, utils_1.assert)(pageRoute.routeType === 'FUNCTION');
            return;
        }
        else {
            const url = (0, resolveRouteString_1.getUrlFromRouteString)(pageRoute.routeString);
            if (!url) {
                // Abort since no URL can be deduced from a parameterized Route String
                return;
            }
            urlOriginal = url;
        }
        (0, utils_1.assert)(urlOriginal.startsWith('/'));
        // Already included in a onBeforePrerenderStart() hook
        if (prerenderContext.pageContexts.find((pageContext) => isSameUrl(pageContext.urlOriginal, urlOriginal))) {
            return;
        }
        const routeParams = {};
        const pageContext = createPageContext(urlOriginal, renderContext, prerenderContext);
        (0, utils_1.objectAssign)(pageContext, {
            _providedByHook: null,
            routeParams,
            _pageId: pageId,
            _routeMatches: [
                {
                    pageId,
                    routeType: pageRoute.routeType,
                    routeString: urlOriginal,
                    routeParams
                }
            ]
        });
        (0, utils_1.objectAssign)(pageContext, await (0, renderPageContext_1.loadPageFilesServer)(pageContext));
        prerenderContext.pageContexts.push(pageContext);
    })));
}
function createPageContext(urlOriginal, renderContext, prerenderContext) {
    const pageContext = {};
    const pageContextInit = {
        urlOriginal,
        ...prerenderContext.pageContextInit
    };
    {
        const pageContextInitAddendum = (0, renderPageContext_1.initPageContext)(pageContextInit, renderContext);
        (0, utils_1.objectAssign)(pageContext, pageContextInitAddendum);
    }
    (0, utils_1.objectAssign)(pageContext, {
        _urlHandler: null,
        _noExtraDir: prerenderContext._noExtraDir,
        _prerenderContext: prerenderContext
    });
    (0, addComputedUrlProps_1.addComputedUrlProps)(pageContext, 
    // We set `enumerable` to `false` to avoid computed URL properties from being iterated & copied in a onPrerenderStart() hook, e.g. /examples/i18n/
    false);
    return pageContext;
}
async function callOnPrerenderStartHook(prerenderContext, renderContext) {
    let onPrerenderStartHook;
    // V1 design
    if (renderContext.pageConfigs.length > 0) {
        const configElement = renderContext.pageConfigGlobal.onPrerenderStart;
        if (configElement) {
            const hookFn = configElement.configValue;
            const hookFilePath = configElement.codeFilePath;
            (0, utils_1.assert)(hookFilePath);
            if (hookFn) {
                onPrerenderStartHook = {
                    hookFn,
                    hookName: 'onPrerenderStart',
                    hookFilePath
                };
            }
        }
    }
    // Old design
    // TODO/v1-release: remove
    if (renderContext.pageConfigs.length === 0) {
        const pageFilesWithOnBeforePrerenderHook = renderContext.pageFilesAll.filter((p) => {
            assertExportNames(p);
            if (!p.exportNames?.includes('onBeforePrerender'))
                return false;
            (0, utils_1.assertUsage)(p.fileType !== '.page.client', `${p.filePath} (which is a \`.page.client.js\` file) has \`export { onBeforePrerender }\` but it is only allowed in \`.page.server.js\` or \`.page.js\` files`);
            (0, utils_1.assertUsage)(p.isDefaultPageFile, `${p.filePath} has \`export { onBeforePrerender }\` but it is only allowed in \`_defaut.page.\` files`);
            return true;
        });
        if (pageFilesWithOnBeforePrerenderHook.length === 0) {
            return;
        }
        (0, utils_1.assertUsage)(pageFilesWithOnBeforePrerenderHook.length === 1, 'There can be only one `onBeforePrerender()` hook. If you need to be able to define several, open a new GitHub issue.');
        await Promise.all(pageFilesWithOnBeforePrerenderHook.map((p) => p.loadFile?.()));
        const hooks = pageFilesWithOnBeforePrerenderHook.map((p) => {
            (0, utils_1.assert)(p.fileExports);
            const { onBeforePrerender } = p.fileExports;
            (0, utils_1.assert)(onBeforePrerender);
            const hookFilePath = p.filePath;
            return { hookFilePath, onBeforePrerender };
        });
        (0, utils_1.assert)(hooks.length === 1);
        const hook = hooks[0];
        onPrerenderStartHook = {
            hookFn: hook.onBeforePrerender,
            hookFilePath: hook.hookFilePath,
            hookName: 'onBeforePrerender'
        };
    }
    if (!onPrerenderStartHook) {
        return;
    }
    const msgPrefix = `The ${onPrerenderStartHook.hookName}() hook defined by ${onPrerenderStartHook.hookFilePath}`;
    const { hookFn, hookFilePath, hookName } = onPrerenderStartHook;
    (0, utils_1.assertUsage)((0, utils_1.isCallable)(hookFn), `${msgPrefix} should be a function.`);
    prerenderContext.pageContexts.forEach((pageContext) => {
        Object.defineProperty(pageContext, 'url', {
            // TODO/v1-release: remove warning
            get() {
                (0, utils_1.assertWarning)(false, msgPrefix +
                    ' uses pageContext.url but it should use pageContext.urlOriginal instead. (See https://vite-plugin-ssr.com/migration/0.4.23 for more information.)', { showStackTrace: true, onlyOnce: true });
                return pageContext.urlOriginal;
            },
            enumerable: false,
            configurable: true
        });
        (0, utils_1.assert)((0, utils_1.hasPropertyGetter)(pageContext, 'url'));
        (0, utils_1.assert)(pageContext.urlOriginal);
        pageContext._urlOriginalBeforeHook = pageContext.urlOriginal;
    });
    const docLink = 'https://vite-plugin-ssr.com/i18n#pre-rendering';
    let result = await (0, utils_1.callHookWithTimeout)(() => hookFn({
        pageContexts: prerenderContext.pageContexts,
        // TODO/v1-release: remove warning
        get prerenderPageContexts() {
            (0, utils_1.assertWarning)(false, `prerenderPageContexts has been renamed pageContexts, see ${docLink}`, {
                showStackTrace: true,
                onlyOnce: true
            });
            return prerenderContext.pageContexts;
        }
    }), hookName, hookFilePath);
    if (result === null || result === undefined) {
        return;
    }
    const errPrefix = `The ${hookName}() hook exported by ${hookFilePath}`;
    const rightUsage = `${errPrefix} should return \`null\`, \`undefined\`, or \`{ prerenderContext: { pageContexts } }\`.`;
    // TODO/v1-release: remove
    if ((0, utils_1.hasProp)(result, 'globalContext')) {
        (0, utils_1.assertUsage)((0, utils_1.isObjectWithKeys)(result, ['globalContext']) &&
            (0, utils_1.hasProp)(result, 'globalContext', 'object') &&
            (0, utils_1.hasProp)(result.globalContext, 'prerenderPageContexts', 'array'), rightUsage);
        (0, utils_1.assertWarning)(false, `${errPrefix} returns \`{ globalContext: { prerenderPageContexts } }\` but the return value has been renamed to \`{ prerenderContext: { pageContexts } }\`, see ${docLink}`, { onlyOnce: true, showStackTrace: false });
        result = {
            prerenderContext: {
                pageContexts: result.globalContext.prerenderPageContexts
            }
        };
    }
    (0, utils_1.assertUsage)((0, utils_1.isObjectWithKeys)(result, ['prerenderContext']) &&
        (0, utils_1.hasProp)(result, 'prerenderContext', 'object') &&
        (0, utils_1.hasProp)(result.prerenderContext, 'pageContexts', 'array'), rightUsage);
    prerenderContext.pageContexts = result.prerenderContext.pageContexts;
    prerenderContext.pageContexts.forEach((pageContext) => {
        if (!(0, utils_1.hasPropertyGetter)(pageContext, 'url') && pageContext.url) {
            (0, utils_1.assertWarning)(false, msgPrefix +
                ' provided pageContext.url but it should provide pageContext.urlOriginal instead, see https://vite-plugin-ssr.com/migration/0.4.23', { showStackTrace: false, onlyOnce: true });
            pageContext.urlOriginal = pageContext.url;
        }
        delete pageContext.url;
    });
    prerenderContext.pageContexts.forEach((pageContext) => {
        if (pageContext.urlOriginal !== pageContext._urlOriginalBeforeHook) {
            pageContext._urlOriginalModifiedByHook = {
                hookFilePath,
                hookName
            };
        }
    });
}
async function routeAndPrerender(prerenderContext, htmlFiles, prerenderPageIds, concurrencyLimit) {
    const globalContext = (0, globalContext_1.getGlobalContext)();
    (0, utils_1.assert)(globalContext.isPrerendering);
    // Route all URLs
    await Promise.all(prerenderContext.pageContexts.map((pageContext) => concurrencyLimit(async () => {
        const { urlOriginal } = pageContext;
        (0, utils_1.assert)(urlOriginal);
        const routeResult = await (0, route_1.route)(pageContext);
        (0, utils_1.assert)((0, utils_1.hasProp)(routeResult.pageContextAddendum, '_pageId', 'null') ||
            (0, utils_1.hasProp)(routeResult.pageContextAddendum, '_pageId', 'string'));
        if (routeResult.pageContextAddendum._pageId === null) {
            let hookName;
            let hookFilePath;
            if (pageContext._providedByHook) {
                hookName = pageContext._providedByHook.hookName;
                hookFilePath = pageContext._providedByHook.hookFilePath;
            }
            else if (pageContext._urlOriginalModifiedByHook) {
                hookName = pageContext._urlOriginalModifiedByHook.hookName;
                hookFilePath = pageContext._urlOriginalModifiedByHook.hookFilePath;
            }
            if (hookName) {
                (0, utils_1.assert)(hookFilePath);
                (0, utils_1.assertUsage)(false, `The ${hookName}() hook defined by ${hookFilePath} returns a URL '${urlOriginal}' that doesn't match any of your page routes. Make sure that the URLs returned by ${hookName}() always match the route of a page.`);
            }
            else {
                // `prerenderHookFile` is `null` when the URL was deduced by the Filesytem Routing of `.page.js` files. The `onBeforeRoute()` can override Filesystem Routing; it is therefore expected that the deduced URL may not match any page.
                (0, utils_1.assert)(routeResult.pageContextAddendum._routingProvidedByOnBeforeRouteHook);
                // Abort since the URL doesn't correspond to any page
                return;
            }
        }
        (0, utils_1.assert)(routeResult.pageContextAddendum._pageId);
        (0, utils_1.objectAssign)(pageContext, routeResult.pageContextAddendum);
        const { _pageId: pageId } = pageContext;
        const pageFilesData = await (0, renderPageContext_1.loadPageFilesServer)(pageContext);
        (0, utils_1.objectAssign)(pageContext, pageFilesData);
        let usesClientRouter;
        {
            if (pageContext._pageConfigs.length > 0) {
                const pageConfig = pageContext._pageConfigs.find((p) => p.pageId === pageId);
                (0, utils_1.assert)(pageConfig);
                usesClientRouter = (0, utils_2.getConfigValue)(pageConfig, 'clientRouting', 'boolean') ?? false;
            }
            else {
                usesClientRouter = globalContext.pluginManifest.usesClientRouter;
            }
        }
        (0, utils_1.objectAssign)(pageContext, {
            is404: null,
            _usesClientRouter: usesClientRouter
        });
        const { documentHtml, pageContextSerialized } = await (0, renderPageContext_1.prerenderPageContext)(pageContext);
        htmlFiles.push({
            urlOriginal,
            pageContext,
            htmlString: documentHtml,
            pageContextSerialized,
            doNotCreateExtraDirectory: prerenderContext._noExtraDir,
            pageId
        });
        prerenderPageIds[pageId] = pageContext;
    })));
}
function warnContradictoryNoPrerenderList(prerenderPageIds, doNotPrerenderList) {
    Object.entries(prerenderPageIds).forEach(([pageId, pageContext]) => {
        const doNotPrerenderListEntry = doNotPrerenderList.find((p) => p.pageId === pageId);
        const { urlOriginal, _providedByHook: providedByHook } = pageContext;
        {
            const isContradictory = !!doNotPrerenderListEntry && providedByHook;
            if (!isContradictory)
                return;
        }
        const { setByConfigName, setByConfigValue, setByConfigFile } = doNotPrerenderListEntry;
        (0, utils_1.assertWarning)(false, `The ${providedByHook.hookName}() hook defined by ${providedByHook.hookFilePath} returns the URL '${urlOriginal}', while ${setByConfigFile} sets the config '${setByConfigName}' to ${setByConfigValue}. This is contradictory: either don't set the config '${setByConfigName}' to ${setByConfigValue} or remove the URL '${urlOriginal}' from the list of URLs to be pre-rendered.`, { onlyOnce: true, showStackTrace: false });
    });
}
function warnMissingPages(prerenderPageIds, doNotPrerenderList, renderContext, partial) {
    const isV1 = renderContext.pageConfigs.length > 0;
    const hookName = isV1 ? 'prerender' : 'onBeforePrerenderStart';
    const getPageAt = isV1 ? (pageId) => `defined at ${pageId}` : (pageId) => `\`${pageId}.page.*\``;
    renderContext.allPageIds
        .filter((pageId) => !prerenderPageIds[pageId])
        .filter((pageId) => !doNotPrerenderList.find((p) => p.pageId === pageId))
        .filter((pageId) => !(0, error_page_1.isErrorPage)(pageId, renderContext.pageConfigs))
        .forEach((pageId) => {
        const pageAt = getPageAt(pageId);
        (0, utils_1.assertWarning)(partial, `Cannot pre-render page ${pageAt} because it has a non-static route, and no ${hookName}() hook returned (an) URL(s) matching the page's route. Either use a ${hookName}() hook to pre-render the page, or use the option \`prerender.partial\` to suppress this warning, see https://vite-plugin-ssr.com/prerender-config`, { showStackTrace: false, onlyOnce: true });
    });
}
async function prerender404(htmlFiles, renderContext, prerenderContext) {
    if (!htmlFiles.find(({ urlOriginal }) => urlOriginal === '/404')) {
        const result = await (0, renderPageContext_1.prerender404Page)(renderContext, prerenderContext.pageContextInit);
        if (result) {
            const urlOriginal = '/404';
            const { documentHtml, pageContext } = result;
            htmlFiles.push({
                urlOriginal,
                pageContext,
                htmlString: documentHtml,
                pageContextSerialized: null,
                doNotCreateExtraDirectory: true,
                pageId: null
            });
        }
    }
}
async function writeHtmlFile({ urlOriginal, pageContext, htmlString, pageContextSerialized, doNotCreateExtraDirectory }, root, outDirClient, concurrencyLimit, onPagePrerender, logLevel) {
    (0, utils_1.assert)(urlOriginal.startsWith('/'));
    const writeJobs = [
        write(urlOriginal, pageContext, '.html', htmlString, root, outDirClient, doNotCreateExtraDirectory, concurrencyLimit, onPagePrerender, logLevel)
    ];
    if (pageContextSerialized !== null) {
        writeJobs.push(write(urlOriginal, pageContext, '.pageContext.json', pageContextSerialized, root, outDirClient, doNotCreateExtraDirectory, concurrencyLimit, onPagePrerender, logLevel));
    }
    await Promise.all(writeJobs);
}
function write(urlOriginal, pageContext, fileExtension, fileContent, root, outDirClient, doNotCreateExtraDirectory, concurrencyLimit, onPagePrerender, logLevel) {
    return concurrencyLimit(async () => {
        let fileUrl;
        if (fileExtension === '.html') {
            fileUrl = (0, utils_1.urlToFile)(urlOriginal, '.html', doNotCreateExtraDirectory);
        }
        else {
            fileUrl = (0, getPageContextRequestUrl_1.getPageContextRequestUrl)(urlOriginal);
        }
        (0, utils_1.assertPosixPath)(fileUrl);
        (0, utils_1.assert)(fileUrl.startsWith('/'));
        const filePathRelative = fileUrl.slice(1);
        (0, utils_1.assert)(!filePathRelative.startsWith('/'));
        (0, utils_1.assertPosixPath)(outDirClient);
        (0, utils_1.assertPosixPath)(filePathRelative);
        const filePath = path_1.default.posix.join(outDirClient, filePathRelative);
        if (onPagePrerender) {
            const prerenderPageContext = {};
            (0, utils_1.objectAssign)(prerenderPageContext, pageContext);
            (0, utils_1.objectAssign)(prerenderPageContext, {
                _prerenderResult: {
                    filePath,
                    fileContent
                }
            });
            await onPagePrerender(prerenderPageContext);
        }
        else {
            const { promises } = require('fs');
            const { writeFile, mkdir } = promises;
            await mkdir(path_1.default.posix.dirname(filePath), { recursive: true });
            await writeFile(filePath, fileContent);
            if (logLevel === 'info') {
                (0, utils_1.assertPosixPath)(root);
                (0, utils_1.assertPosixPath)(outDirClient);
                let outDirClientRelative = path_1.default.posix.relative(root, outDirClient);
                if (!outDirClientRelative.endsWith('/')) {
                    outDirClientRelative = outDirClientRelative + '/';
                }
                console.log(`${picocolors_1.default.gray(outDirClientRelative)}${picocolors_1.default.blue(filePathRelative)}`);
            }
        }
    });
}
function normalizeOnPrerenderHookResult(prerenderResult, prerenderHookFile, hookName) {
    if (Array.isArray(prerenderResult)) {
        return prerenderResult.map(normalize);
    }
    else {
        return [normalize(prerenderResult)];
    }
    function normalize(prerenderElement) {
        if (typeof prerenderElement === 'string') {
            prerenderElement = { url: prerenderElement, pageContext: null };
        }
        const errMsg1 = `The ${hookName}() hook defined by ${prerenderHookFile} returned`;
        const errMsg2 = `${errMsg1} an invalid value`;
        const errHint = `Make sure your ${hookName}() hook returns an object \`{ url, pageContext }\` or an array of such objects.`;
        (0, utils_1.assertUsage)((0, utils_1.isPlainObject)(prerenderElement), `${errMsg2}. ${errHint}`);
        (0, utils_1.assertUsage)((0, utils_1.hasProp)(prerenderElement, 'url'), `${errMsg2}: \`url\` is missing. ${errHint}`);
        (0, utils_1.assertUsage)((0, utils_1.hasProp)(prerenderElement, 'url', 'string'), `${errMsg2}: \`url\` should be a string (but \`typeof url === "${typeof prerenderElement.url}"\`).`);
        (0, utils_1.assertUsage)(prerenderElement.url.startsWith('/'), `${errMsg1} a URL with an invalid value '${prerenderElement.url}' which doesn't start with '/'. Make sure each URL starts with '/'.`);
        Object.keys(prerenderElement).forEach((key) => {
            (0, utils_1.assertUsage)(key === 'url' || key === 'pageContext', `${errMsg2}: unexpected object key \`${key}\`. ${errHint}`);
        });
        if (!(0, utils_1.hasProp)(prerenderElement, 'pageContext')) {
            prerenderElement.pageContext = null;
        }
        else if (!(0, utils_1.hasProp)(prerenderElement, 'pageContext', 'null')) {
            (0, utils_1.assertUsage)((0, utils_1.hasProp)(prerenderElement, 'pageContext', 'object'), `${errMsg1} an invalid \`pageContext\` value: make sure \`pageContext\` is an object.`);
            (0, utils_1.assertUsage)((0, utils_1.isPlainObject)(prerenderElement.pageContext), `${errMsg1} an invalid \`pageContext\` object: make sure \`pageContext\` is a plain JavaScript object.`);
        }
        (0, utils_1.assert)((0, utils_1.hasProp)(prerenderElement, 'pageContext', 'object') || (0, utils_1.hasProp)(prerenderElement, 'pageContext', 'null'));
        return prerenderElement;
    }
}
function checkOutdatedOptions(options) {
    (0, utils_1.assertUsage)(options.root === undefined, 'Option `prerender({ root })` deprecated: set `prerender({ viteConfig: { root }})` instead.');
    (0, utils_1.assertUsage)(options.configFile === undefined, 'Option `prerender({ configFile })` deprecated: set `prerender({ viteConfig: { configFile }})` instead.');
    ['noExtraDir', 'partial', 'parallel'].forEach((prop) => {
        (0, utils_1.assertUsage)(options[prop] === undefined, `[prerender()] Option \`${prop}\` is deprecated. Define \`${prop}\` in \`vite.config.js\` instead. See https://vite-plugin-ssr.com/prerender-config`);
    });
    ['base', 'outDir'].forEach((prop) => {
        (0, utils_1.assertWarning)(options[prop] === undefined, `[prerender()] Option \`${prop}\` is outdated and has no effect (vite-plugin-ssr now automatically determines \`${prop}\`)`, {
            showStackTrace: false,
            onlyOnce: true
        });
    });
}
function disableReactStreaming() {
    let mod;
    try {
        mod = (0, utils_1.loadModuleAtRuntime)('react-streaming/server');
    }
    catch {
        return;
    }
    const { disable } = mod;
    disable();
}
function assertLoadedConfig(viteConfig, options) {
    if (viteConfig.plugins.some((p) => p.name.startsWith('vite-plugin-ssr'))) {
        return;
    }
    const { configFile } = viteConfig;
    if (configFile) {
        (0, utils_1.assertUsage)(false, `${configFile} is missing vite-plugin-ssr. Add vite-plugin-ssr to \`${configFile}\`.`);
    }
    else {
        if (!options.viteConfig) {
            (0, utils_1.assertUsage)(false, `[prerender()] No \`vite.config.js\` file found at \`${process.cwd()}\`. Use the option \`prerender({ viteConfig })\`.`);
        }
        else {
            (0, utils_1.assertUsage)(false, '[prerender()] The Vite config `prerender({ viteConfig })` is missing vite-plugin-ssr.');
        }
    }
}
function isSameUrl(url1, url2) {
    return normalizeUrl(url1) === normalizeUrl(url2);
}
function normalizeUrl(url) {
    return '/' + url.split('/').filter(Boolean).join('/');
}
function runPrerenderForceExit() {
    // Force exit; known situations where pre-rendering is hanging:
    //  - https://github.com/brillout/vite-plugin-ssr/discussions/774#discussioncomment-5584551
    //  - https://github.com/brillout/vite-plugin-ssr/issues/807#issuecomment-1519010902
    process.exit(0);
    /* I guess there is no need to tell the user about it? Let's see if a user complains.
     * I don't known whether there is a way to call process.exit(0) only if needed, thus I'm not sure if there is a way to conditionally show a assertInfo().
    assertInfo(false, "Pre-rendering was forced exit. (Didn't gracefully exit because the event queue isn't empty. This is usally fine, see ...", { onlyOnce: false })
    */
}
exports.runPrerenderForceExit = runPrerenderForceExit;
