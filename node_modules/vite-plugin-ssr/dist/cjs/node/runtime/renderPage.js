"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderPage = void 0;
const renderPageContext_1 = require("./renderPage/renderPageContext");
const route_1 = require("../../shared/route");
const error_page_1 = require("../../shared/error-page");
const utils_1 = require("./utils");
const addComputedUrlProps_1 = require("../../shared/addComputedUrlProps");
const RenderErrorPage_1 = require("../../shared/route/RenderErrorPage");
const globalContext_1 = require("./globalContext");
const handlePageContextRequestUrl_1 = require("./renderPage/handlePageContextRequestUrl");
const logError_1 = require("./renderPage/logError");
const assertArguments_1 = require("./renderPage/assertArguments");
const handleErrorWithoutErrorPage_1 = require("./renderPage/handleErrorWithoutErrorPage");
const log404_1 = require("./renderPage/log404");
const onRenderResult_1 = require("./renderPage/onRenderResult");
// `renderPage()` calls `renderPageAttempt()` while ensuring that errors are `console.error(err)` instead of `throw err`, so that `vite-plugin-ssr` never triggers a server shut down. (Throwing an error in an Express.js middleware shuts down the whole Express.js server.)
async function renderPage(pageContextInit) {
    (0, assertArguments_1.assertArguments)(...arguments);
    (0, utils_1.assert)((0, utils_1.hasProp)(pageContextInit, 'urlOriginal', 'string'));
    (0, utils_1.assertServerEnv)();
    let renderContext;
    try {
        await (0, globalContext_1.initGlobalContext)();
        renderContext = await (0, renderPageContext_1.getRenderContext)();
    }
    catch (err) {
        // Errors are expected since assertUsage() is used in both initGlobalContext() and getRenderContext().
        // initGlobalContext() and getRenderContext() don't call any user hooks => err isn't thrown from user code => we use logErrorWithoutVite() instead of logErrorWithVite().
        (0, logError_1.logErrorWithoutVite)(err);
        const pageContextErr = getPageContextErr(err, pageContextInit);
        return pageContextErr;
    }
    let pageContextOriginal;
    let pageContextOriginalPartial;
    let errOriginal;
    {
        const pageContext = {};
        let errored;
        try {
            pageContextOriginal = await renderPageAttempt(pageContextInit, pageContext, renderContext);
            errored = false;
        }
        catch (errOriginal_) {
            errored = true;
            errOriginal = errOriginal_;
            pageContextOriginalPartial = pageContext;
        }
        if (errored) {
            (0, utils_1.assert)(errOriginal);
        }
        else {
            (0, utils_1.assert)(pageContextOriginal === pageContext);
        }
    }
    const isV1 = renderContext.pageConfigs.length > 0;
    const errorPageIsMissing = !(0, error_page_1.getErrorPageId)(renderContext.pageFilesAll, renderContext.pageConfigs);
    if (errOriginal === undefined) {
        (0, utils_1.assert)(pageContextOriginal);
        const statusCode = pageContextOriginal.httpResponse?.statusCode ?? null;
        if (!!pageContextOriginal && 'is404' in pageContextOriginal && pageContextOriginal.is404 === true) {
            (0, utils_1.assert)(statusCode === 404 ||
                // No HTTP response if user didn't define an error page
                statusCode === null);
            // We call onRenderResult() before any log/warning
            (0, onRenderResult_1.executeOnRenderResult)(pageContextInit, true, statusCode);
            if (errorPageIsMissing) {
                (0, utils_1.assert)(pageContextOriginal.httpResponse === null);
                (0, handleErrorWithoutErrorPage_1.warnMissingErrorPage)(isV1);
            }
            (0, log404_1.log404)(pageContextOriginal);
        }
        else {
            if (pageContextOriginal.httpResponse) {
                (0, utils_1.assert)(statusCode === 200);
                (0, onRenderResult_1.executeOnRenderResult)(pageContextInit, false, statusCode);
            }
            else {
                // Don't call onRenderResult() hook if rendering was skipped (e.g. /favicon.ico HTTP requests, or HTTP requests that don't match the Base URL)
            }
        }
        return pageContextOriginal;
    }
    else {
        (0, utils_1.assert)(errOriginal);
        (0, utils_1.assert)(pageContextOriginal === undefined);
        (0, utils_1.assert)(pageContextOriginalPartial);
        // We call onRenderResult() before any log/warning
        (0, onRenderResult_1.executeOnRenderResult)(pageContextInit, true, 
        // We can't determine the status code before actually trying to render the error page (it can be either `null` or `500`)
        null);
        if (errorPageIsMissing) {
            (0, handleErrorWithoutErrorPage_1.warnMissingErrorPage)(isV1);
        }
        (0, logError_1.logErrorWithVite)(errOriginal);
        let pageContextErrorPage;
        let errErrorPage;
        try {
            pageContextErrorPage = await renderErrorPage(pageContextInit, errOriginal, pageContextOriginalPartial, renderContext);
        }
        catch (errErrorPage_) {
            errErrorPage = errErrorPage_;
        }
        if (errErrorPage === undefined) {
            (0, utils_1.assert)(pageContextErrorPage);
            return pageContextErrorPage;
        }
        else {
            (0, utils_1.assert)(errErrorPage);
            (0, utils_1.assert)(pageContextErrorPage === undefined);
            if ((0, logError_1.isNewError)(errErrorPage, errOriginal)) {
                (0, logError_1.logErrorWithVite)(errErrorPage);
            }
            const pageContextErr = getPageContextErr(errOriginal, pageContextInit);
            (0, utils_1.assert)(pageContextErr.httpResponse === null);
            return pageContextErr;
        }
    }
}
exports.renderPage = renderPage;
function getPageContextErr(err, pageContextInit) {
    const pageContextErr = {};
    (0, utils_1.objectAssign)(pageContextErr, pageContextInit);
    (0, utils_1.objectAssign)(pageContextErr, {
        httpResponse: null,
        errorWhileRendering: err
    });
    return pageContextErr;
}
async function renderPageAttempt(pageContextInit, pageContext, renderContext) {
    {
        const { urlOriginal } = pageContextInit;
        const isViteClientRequest = urlOriginal.endsWith('/@vite/client') || urlOriginal.startsWith('/@fs/');
        (0, utils_1.assertWarning)(!isViteClientRequest, `The vite-plugin-ssr middleware renderPage() was called with the URL ${urlOriginal} which is unexpected because the HTTP request should have already been handled by Vite's development middleware. Make sure to 1. install Vite's development middleware and 2. add Vite's middleware *before* vite-plugin-ssr's middleware, see https://vite-plugin-ssr.com/renderPage`, { onlyOnce: true, showStackTrace: false });
        if (urlOriginal.endsWith('/__vite_ping') ||
            urlOriginal.endsWith('/favicon.ico') ||
            !(0, utils_1.isParsable)(urlOriginal) ||
            isViteClientRequest) {
            (0, utils_1.objectAssign)(pageContext, pageContextInit);
            (0, utils_1.objectAssign)(pageContext, { httpResponse: null, errorWhileRendering: null });
            return pageContext;
        }
    }
    {
        const pageContextInitAddendum = (0, renderPageContext_1.initPageContext)(pageContextInit, renderContext);
        (0, utils_1.objectAssign)(pageContext, pageContextInitAddendum);
    }
    {
        const pageContextAddendum = handleUrl(pageContext);
        (0, utils_1.objectAssign)(pageContext, pageContextAddendum);
    }
    if (!pageContext._hasBaseServer) {
        (0, utils_1.objectAssign)(pageContext, { httpResponse: null, errorWhileRendering: null });
        return pageContext;
    }
    (0, addComputedUrlProps_1.addComputedUrlProps)(pageContext);
    // *** Route ***
    const routeResult = await (0, route_1.route)(pageContext);
    (0, utils_1.objectAssign)(pageContext, routeResult.pageContextAddendum);
    const is404 = (0, utils_1.hasProp)(pageContext, '_pageId', 'string') ? null : true;
    (0, utils_1.objectAssign)(pageContext, { is404 });
    (0, utils_1.objectAssign)(pageContext, { errorWhileRendering: null });
    const pageContextAfterRender = await (0, renderPageContext_1.renderPageContext)(pageContext);
    (0, utils_1.assert)(pageContext === pageContextAfterRender);
    return pageContextAfterRender;
}
async function renderErrorPage(pageContextInit, errOriginal, pageContextOriginal, renderContext) {
    const pageContext = {};
    {
        const pageContextInitAddendum = (0, renderPageContext_1.initPageContext)(pageContextInit, renderContext);
        (0, utils_1.objectAssign)(pageContext, pageContextInitAddendum);
    }
    {
        const pageContextAddendum = handleUrl(pageContext);
        (0, utils_1.objectAssign)(pageContext, pageContextAddendum);
    }
    (0, utils_1.assert)(errOriginal);
    (0, utils_1.objectAssign)(pageContext, {
        is404: false,
        _pageId: null,
        errorWhileRendering: errOriginal,
        routeParams: {}
    });
    (0, addComputedUrlProps_1.addComputedUrlProps)(pageContext);
    if ((0, RenderErrorPage_1.isRenderErrorPageException)(pageContext.errorWhileRendering)) {
        (0, utils_1.objectAssign)(pageContext, { is404: true });
        (0, utils_1.objectAssign)(pageContext, pageContext.errorWhileRendering.pageContext);
    }
    (0, utils_1.objectAssign)(pageContext, {
        _routeMatches: pageContextOriginal._routeMatches || 'ROUTE_ERROR'
    });
    (0, utils_1.assert)(pageContext.errorWhileRendering);
    return (0, renderPageContext_1.renderPageContext)(pageContext);
}
function handleUrl(pageContext) {
    const { urlOriginal } = pageContext;
    (0, utils_1.assert)(urlOriginal.startsWith('/') || urlOriginal.startsWith('http'));
    const { urlWithoutPageContextRequestSuffix, isPageContextRequest } = (0, handlePageContextRequestUrl_1.handlePageContextRequestUrl)(urlOriginal);
    const { hasBaseServer } = (0, utils_1.parseUrl)(urlWithoutPageContextRequestSuffix, pageContext._baseServer);
    const pageContextAddendum = {
        isClientSideNavigation: isPageContextRequest,
        _hasBaseServer: hasBaseServer,
        // The onBeforeRoute() hook may modify pageContext.urlOriginal (e.g. for i18n)
        _urlHandler: (urlOriginal) => (0, handlePageContextRequestUrl_1.handlePageContextRequestUrl)(urlOriginal).urlWithoutPageContextRequestSuffix
    };
    return pageContextAddendum;
}
