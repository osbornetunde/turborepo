"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHttpResponseObject = void 0;
const stream_1 = require("../html/stream");
const inferHtmlTags_1 = require("../html/injectAssets/inferHtmlTags");
const utils_1 = require("../utils");
const renderHtml_1 = require("../html/renderHtml");
const error_page_1 = require("../../../shared/error-page");
async function createHttpResponseObject(htmlRender, renderHook, pageContext) {
    if (htmlRender === null) {
        return null;
    }
    (0, utils_1.assert)(renderHook || typeof htmlRender === 'string');
    let statusCode;
    {
        const isError = !pageContext._pageId || (0, error_page_1.isErrorPage)(pageContext._pageId, pageContext._pageConfigs);
        if (pageContext.errorWhileRendering) {
            (0, utils_1.assert)(isError);
        }
        if (!isError) {
            (0, utils_1.assert)(pageContext.is404 === null);
            statusCode = 200;
        }
        else {
            (0, utils_1.assert)(pageContext.is404 === true || pageContext.is404 === false);
            statusCode = pageContext.is404 ? 404 : 500;
        }
    }
    // The `.pageContext.json` HTTP request's body is generated by `@brillout/json-serializer` thus always a string
    (0, utils_1.assert)(!pageContext.isClientSideNavigation || typeof htmlRender === 'string');
    const streamDocs = 'See https://vite-plugin-ssr.com/stream for more information.';
    const earlyHints = [];
    {
        const assets = await pageContext.__getPageAssets();
        assets.forEach((asset) => {
            // Don't early hint fallback fonts, https://github.com/brillout/vite-plugin-ssr/issues/624
            if (isFontFallback(asset, earlyHints))
                return;
            earlyHints.push({
                ...asset,
                earlyHintLink: (0, inferHtmlTags_1.inferEarlyHintLink)(asset)
            });
        });
    }
    return {
        statusCode,
        contentType: pageContext.isClientSideNavigation ? 'application/json' : 'text/html;charset=utf-8',
        earlyHints,
        get body() {
            if (typeof htmlRender !== 'string') {
                (0, utils_1.assertUsage)(false, errMsg('body', 'Use `pageContext.httpResponse.pipe()` or `pageContext.httpResponse.getBody()` instead'));
            }
            const body = htmlRender;
            return body;
        },
        async getBody() {
            const body = await (0, renderHtml_1.getHtmlString)(htmlRender);
            return body;
        },
        async getNodeStream() {
            (0, utils_1.assertWarning)(false, '`pageContext.httpResponse.getNodeStream()` is outdated, use `pageContext.httpResponse.pipe()` instead. ' +
                streamDocs, { onlyOnce: true, showStackTrace: true });
            const nodeStream = await (0, stream_1.getStreamReadableNode)(htmlRender);
            if (nodeStream === null) {
                (0, utils_1.assertUsage)(false, errMsg('getNodeStream()', fixMsg('readable', 'node')));
            }
            return nodeStream;
        },
        getWebStream() {
            (0, utils_1.assertWarning)(false, '`pageContext.httpResponse.getWebStream(res)` is outdated, use `pageContext.httpResponse.getReadableWebStream(res)` instead. ' +
                streamDocs, { onlyOnce: true, showStackTrace: true });
            const webStream = (0, stream_1.getStreamReadableWeb)(htmlRender);
            if (webStream === null) {
                (0, utils_1.assertUsage)(false, errMsg('getWebStream()', fixMsg('readable', 'web')));
            }
            return webStream;
        },
        getReadableWebStream() {
            const webStream = (0, stream_1.getStreamReadableWeb)(htmlRender);
            if (webStream === null) {
                (0, utils_1.assertUsage)(false, errMsg('getReadableWebStream()', fixMsg('readable', 'web')));
            }
            return webStream;
        },
        pipeToWebWritable(writable) {
            (0, utils_1.assertWarning)(false, '`pageContext.httpResponse.pipeToWebWritable(res)` is outdated, use `pageContext.httpResponse.pipe(res)` instead. ' +
                streamDocs, { onlyOnce: true, showStackTrace: true });
            const success = (0, stream_1.pipeToStreamWritableWeb)(htmlRender, writable);
            if (!success) {
                (0, utils_1.assertUsage)(false, errMsg('pipeToWebWritable()'));
            }
        },
        pipeToNodeWritable(writable) {
            (0, utils_1.assertWarning)(false, '`pageContext.httpResponse.pipeToNodeWritable(res)` is outdated, use `pageContext.httpResponse.pipe(res)` instead. ' +
                streamDocs, { onlyOnce: true, showStackTrace: true });
            const success = (0, stream_1.pipeToStreamWritableNode)(htmlRender, writable);
            if (!success) {
                (0, utils_1.assertUsage)(false, errMsg('pipeToNodeWritable()'));
            }
        },
        pipe(writable) {
            if ((0, stream_1.isStreamWritableWeb)(writable)) {
                const success = (0, stream_1.pipeToStreamWritableWeb)(htmlRender, writable);
                if (!success) {
                    (0, utils_1.assertUsage)(false, errMsg('pipe()'));
                }
                return;
            }
            if ((0, stream_1.isStreamWritableNode)(writable)) {
                const success = (0, stream_1.pipeToStreamWritableNode)(htmlRender, writable);
                if (!success) {
                    (0, utils_1.assertUsage)(false, errMsg('pipe()'));
                }
                return;
            }
            (0, utils_1.assertUsage)(false, `The argument \`writable\` passed to \`pageContext.httpResponse.pipe(writable)\` doesn't seem to be ${(0, stream_1.getStreamName)('writable', 'web')} nor ${(0, stream_1.getStreamName)('writable', 'node')}.`);
        }
    };
    function errMsg(method, fixMsg) {
        let htmlRenderName;
        if (typeof htmlRender === 'string') {
            htmlRenderName = 'an HTML string';
        }
        else if ((0, stream_1.isStream)(htmlRender)) {
            htmlRenderName = (0, stream_1.inferStreamName)(htmlRender);
        }
        else {
            (0, utils_1.assert)(false);
        }
        (0, utils_1.assert)(['a ', 'an ', 'the '].some((s) => htmlRenderName.startsWith(s)));
        (0, utils_1.assert)(!fixMsg || !fixMsg.endsWith('.'));
        (0, utils_1.assert)(renderHook);
        const { hookFilePath, hookName } = renderHook;
        return [
            `pageContext.httpResponse.${method} can't be used because the ${hookName}()\ hook defined by ${hookFilePath} provides ${htmlRenderName}`,
            fixMsg,
            streamDocs
        ]
            .filter(Boolean)
            .join('. ');
    }
    function fixMsg(type, standard) {
        const streamName = (0, stream_1.getStreamName)(type, standard);
        (0, utils_1.assert)(['a ', 'an ', 'the '].some((s) => streamName.startsWith(s)));
        (0, utils_1.assert)(renderHook);
        const { hookFilePath, hookName } = renderHook;
        return `Make sure the ${hookName}() defined by ${hookFilePath} hook provides ${streamName} instead`;
    }
}
exports.createHttpResponseObject = createHttpResponseObject;
function isFontFallback(asset, earlyHints) {
    if (asset.assetType !== 'font') {
        return false;
    }
    const fontUrlBase = removeFileExtentionAndHash(asset.src);
    return earlyHints.some((hint) => {
        return hint.assetType === 'font' && removeFileExtentionAndHash(hint.src) === fontUrlBase;
    });
}
function removeFileExtentionAndHash(assetUrl) {
    (0, utils_1.assert)(!assetUrl.includes('\\'));
    // The logic below doesn't work for '/assets/chunk-0e184ced.js'
    (0, utils_1.assert)(!assetUrl.endsWith('.js'));
    const paths = assetUrl.split('/');
    {
        const filename = paths[paths.length - 1];
        const filenameParts = filename.split('.');
        (0, utils_1.assert)(filenameParts.length >= 2);
        // User may set config.build.rollupOptions.output.assetFileNames => we can't assume the filename to be `*.${hash}.${ext}`
        const filenameBase = filenameParts.slice(0, filenameParts.length === 2 ? -1 : -2);
        (0, utils_1.assert)(filenameBase.length >= 1);
        paths[paths.length - 1] = filenameBase.join('.');
    }
    return paths.join('/');
}
