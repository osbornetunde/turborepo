"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRenderContext = exports.initPageContext = exports.loadPageFilesServer = exports.prerender404Page = exports.prerenderPageContext = exports.renderPageContext = void 0;
const error_page_1 = require("../../../shared/error-page");
const renderHtml_1 = require("../html/renderHtml");
const getPageFiles_1 = require("../../../shared/getPageFiles");
const utils_1 = require("../utils");
const serializePageContextClientSide_1 = require("../html/serializePageContextClientSide");
const addComputedUrlProps_1 = require("../../../shared/addComputedUrlProps");
const globalContext_1 = require("../globalContext");
const createHttpResponseObject_1 = require("./createHttpResponseObject");
const logError_1 = require("./logError");
const loadPageFilesServer_1 = require("./loadPageFilesServer");
Object.defineProperty(exports, "loadPageFilesServer", { enumerable: true, get: function () { return loadPageFilesServer_1.loadPageFilesServer; } });
const handleErrorWithoutErrorPage_1 = require("./handleErrorWithoutErrorPage");
const executeOnRenderHtmlHook_1 = require("./executeOnRenderHtmlHook");
const executeOnBeforeRenderHook_1 = require("./executeOnBeforeRenderHook");
async function renderPageContext(pageContext) {
    const isError = pageContext.is404 || pageContext.errorWhileRendering;
    if (isError) {
        (0, utils_1.assert)(pageContext._pageId === null);
        const errorPageId = (0, error_page_1.getErrorPageId)(pageContext._pageFilesAll, pageContext._pageConfigs);
        if (errorPageId) {
            (0, utils_1.objectAssign)(pageContext, { _pageId: errorPageId });
        }
        else {
            // The user hasn't define a `_error.page.js`
            (0, utils_1.objectAssign)(pageContext, { _pageId: null });
            return (0, handleErrorWithoutErrorPage_1.handleErrorWithoutErrorPage)(pageContext);
        }
    }
    // We now resolved `pageContext._pageId`. It can either be the:
    //  - ID of the page matching the routing, or the
    //  - ID of the error page `_error.page.js`.
    (0, utils_1.assert)((0, utils_1.hasProp)(pageContext, '_pageId', 'string'));
    const pageFiles = await (0, loadPageFilesServer_1.loadPageFilesServer)(pageContext);
    (0, utils_1.objectAssign)(pageContext, pageFiles);
    if (!isError) {
        await (0, executeOnBeforeRenderHook_1.executeOnBeforeRenderHooks)(pageContext);
    }
    else {
        try {
            await (0, executeOnBeforeRenderHook_1.executeOnBeforeRenderHooks)(pageContext);
        }
        catch (err) {
            if ((0, logError_1.isNewError)(err, pageContext.errorWhileRendering)) {
                (0, logError_1.logErrorWithVite)(err);
            }
        }
    }
    if (pageContext.isClientSideNavigation) {
        if (isError) {
            (0, utils_1.objectAssign)(pageContext, { _isError: true });
        }
        const body = (0, serializePageContextClientSide_1.serializePageContextClientSide)(pageContext);
        const httpResponse = await (0, createHttpResponseObject_1.createHttpResponseObject)(body, null, pageContext);
        (0, utils_1.objectAssign)(pageContext, { httpResponse });
        return pageContext;
    }
    const renderHookResult = await (0, executeOnRenderHtmlHook_1.executeOnRenderHtmlHook)(pageContext);
    if (renderHookResult.htmlRender === null) {
        (0, utils_1.objectAssign)(pageContext, { httpResponse: null });
        return pageContext;
    }
    else {
        const { htmlRender, renderHook } = renderHookResult;
        const httpResponse = await (0, createHttpResponseObject_1.createHttpResponseObject)(htmlRender, renderHook, pageContext);
        (0, utils_1.objectAssign)(pageContext, { httpResponse });
        return pageContext;
    }
}
exports.renderPageContext = renderPageContext;
async function prerenderPageContext(pageContext) {
    (0, utils_1.objectAssign)(pageContext, {
        isClientSideNavigation: false,
        _urlHandler: null
    });
    (0, addComputedUrlProps_1.addComputedUrlProps)(pageContext);
    await (0, executeOnBeforeRenderHook_1.executeOnBeforeRenderHooks)(pageContext);
    const { htmlRender, renderHook } = await (0, executeOnRenderHtmlHook_1.executeOnRenderHtmlHook)(pageContext);
    (0, utils_1.assertUsage)(htmlRender !== null, `Cannot pre-render '${pageContext.urlOriginal}' because the ${renderHook.hookName}() hook defined by ${renderHook.hookFilePath} didn't return an HTML string.`);
    (0, utils_1.assert)(pageContext.isClientSideNavigation === false);
    const documentHtml = await (0, renderHtml_1.getHtmlString)(htmlRender);
    (0, utils_1.assert)(typeof documentHtml === 'string');
    if (!pageContext._usesClientRouter) {
        return { documentHtml, pageContextSerialized: null, pageContext };
    }
    else {
        const pageContextSerialized = (0, serializePageContextClientSide_1.serializePageContextClientSide)(pageContext);
        return { documentHtml, pageContextSerialized, pageContext };
    }
}
exports.prerenderPageContext = prerenderPageContext;
async function prerender404Page(renderContext, pageContextInit_) {
    const errorPageId = (0, error_page_1.getErrorPageId)(renderContext.pageFilesAll, renderContext.pageConfigs);
    if (!errorPageId) {
        return null;
    }
    const pageContext = {};
    const pageContextInit = {
        urlOriginal: '/fake-404-url',
        ...pageContextInit_
    };
    {
        const pageContextInitAddendum = initPageContext(pageContextInit, renderContext);
        (0, utils_1.objectAssign)(pageContext, pageContextInitAddendum);
    }
    (0, utils_1.objectAssign)(pageContext, {
        _pageId: errorPageId,
        is404: true,
        routeParams: {},
        // `prerender404Page()` is about generating `dist/client/404.html` for static hosts; there is no Client Routing.
        _usesClientRouter: false,
        _routeMatches: []
    });
    const pageFiles = await (0, loadPageFilesServer_1.loadPageFilesServer)(pageContext);
    (0, utils_1.objectAssign)(pageContext, pageFiles);
    return prerenderPageContext(pageContext);
}
exports.prerender404Page = prerender404Page;
function initPageContext(pageContextInit, renderContext) {
    (0, utils_1.assert)(pageContextInit.urlOriginal);
    const globalContext = (0, globalContext_1.getGlobalContext)();
    const pageContextAddendum = {
        ...pageContextInit,
        _objectCreatedByVitePluginSsr: true,
        // The following is defined on `pageContext` because we can eventually make these non-global (e.g. sot that two pages can have different includeAssetsImportedByServer settings)
        _baseServer: globalContext.baseServer,
        _baseAssets: globalContext.baseAssets,
        _includeAssetsImportedByServer: globalContext.includeAssetsImportedByServer,
        // TODO: use GloablContext instead
        _pageFilesAll: renderContext.pageFilesAll,
        _pageConfigs: renderContext.pageConfigs,
        _pageConfigGlobal: renderContext.pageConfigGlobal,
        _allPageIds: renderContext.allPageIds
    };
    return pageContextAddendum;
}
exports.initPageContext = initPageContext;
// TODO: remove getRenderContext() in favor of getGlobalObject() + reloadGlobalContext()
// TODO: impl GlobalNodeContext + GlobalClientContext + GloablContext, and use GlobalContext instead of RenderContext
async function getRenderContext() {
    const globalContext = (0, globalContext_1.getGlobalContext)();
    const { pageFilesAll, allPageIds, pageConfigs, pageConfigGlobal } = await (0, getPageFiles_1.getPageFilesAll)(false, globalContext.isProduction);
    assertNonMixedDesign(pageFilesAll, pageConfigs);
    const renderContext = {
        pageFilesAll: pageFilesAll,
        pageConfigs,
        pageConfigGlobal,
        allPageIds: allPageIds
    };
    return renderContext;
}
exports.getRenderContext = getRenderContext;
function assertNonMixedDesign(pageFilesAll, pageConfigs) {
    if (pageFilesAll.length === 0 || pageConfigs.length === 0)
        return;
    const indent = '- ';
    const v1Files = (0, utils_1.unique)(pageConfigs.map((p) => Object.values(p.configElements).map((c) => indent + c.configDefinedByFile)).flat());
    (0, utils_1.assertUsage)(false, [
        'Mixing the new V1 design with the old V0.4 design is forbidden.',
        'V1 files:',
        ...v1Files,
        'V0.4 files:',
        ...pageFilesAll.map((p) => indent + p.filePath)
    ].join('\n'));
}
