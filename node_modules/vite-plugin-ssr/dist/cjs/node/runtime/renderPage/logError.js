"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNewError = exports.logErrorWithoutVite = exports.logErrorWithVite = void 0;
const RenderErrorPage_1 = require("../../../shared/route/RenderErrorPage");
const utils_1 = require("../utils");
const globalContext_1 = require("../globalContext");
const logTranspileError_1 = require("../shared/logTranspileError");
/** Log errors that don't originate from code transpiled by Vite. I.e. errors that aren't thrown from user code. */
function logErrorWithoutVite(err) {
    assertError(err);
    (0, utils_1.assert)(!(0, RenderErrorPage_1.isRenderErrorPageException)(err));
    consoleError(err);
}
exports.logErrorWithoutVite = logErrorWithoutVite;
/** Handles errors that may originate from code transpiled by Vite. I.e. errors that are thrown from user code. */
function logErrorWithVite(err) {
    assertError(err);
    if ((0, RenderErrorPage_1.isRenderErrorPageException)(err)) {
        return;
    }
    // Avoid logging error twice (not sure if this actually ever happens?)
    if (hasAlreadyLogged(err)) {
        return;
    }
    setAlreadyLogged(err);
    const { viteDevServer } = (0, globalContext_1.getGlobalContext)();
    if (viteDevServer) {
        /* Temporary disable: https://github.com/vitejs/vite/issues/12631
        if (viteDevServer.config.logger.hasErrorLogged(err as Error)) {
          return
        }
        */
        if ((0, utils_1.hasProp)(err, 'stack')) {
            // Apply source maps
            viteDevServer.ssrFixStacktrace(err);
        }
        if ((0, logTranspileError_1.isTranspileError)(err)) {
            // We handle transpile errors globally in logError() because transpile errors can be thrown not only when calling viteDevServer.ssrLoadModule() but also later when calling user hooks (since Vite loads/transpiles user code in a lazy manner)
            (0, logTranspileError_1.logTranspileError)(viteDevServer, err);
            return;
        }
    }
    consoleError(err);
}
exports.logErrorWithVite = logErrorWithVite;
function consoleError(err) {
    // We ensure we print a string; Cloudflare Workers doesn't seem to properly stringify `Error` objects.
    const errStr = ((0, utils_1.hasProp)(err, 'stack') && String(err.stack)) || String(err);
    console.error(errStr);
}
function isNewError(err, errOriginal) {
    assertError(err);
    return !(0, utils_1.isSameErrorMessage)(errOriginal, err) || !hasAlreadyLogged(errOriginal);
}
exports.isNewError = isNewError;
function hasAlreadyLogged(err) {
    if (!(0, utils_1.isObject)(err))
        return false;
    const key = '_wasAlreadyConsoleLogged';
    return err[key] === true;
}
function setAlreadyLogged(err) {
    if (!(0, utils_1.isObject)(err))
        return;
    const key = '_wasAlreadyConsoleLogged';
    err[key] = true;
}
function assertError(err) {
    (0, RenderErrorPage_1.assertRenderErrorPageExceptionUsage)(err);
    if (!(0, utils_1.isObject)(err)) {
        console.warn('[vite-plugin-ssr] The thrown value is:');
        console.warn(err);
        (0, utils_1.assertWarning)(false, "Your source code threw a value that is not an object. Make sure to wrap the value with `new Error()`. For example, if your code throws `throw 'some-string'` then do `throw new Error('some-string')` instead. The thrown value is printed above. Feel free to contact vite-plugin-ssr maintainers to get help.", { showStackTrace: false, onlyOnce: false });
    }
}
