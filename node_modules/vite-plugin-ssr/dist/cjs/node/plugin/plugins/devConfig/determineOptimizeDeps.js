"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineOptimizeDeps = void 0;
const findPageFiles_1 = require("../../shared/findPageFiles");
const utils_1 = require("../../utils");
const getConfigData_1 = require("../importUserCode/v1-design/getConfigData");
async function determineOptimizeDeps(config, configVps, isDev) {
    const { entries, include } = await getPageDeps(config, configVps, isDev);
    include.push(...getExtensionsDeps(configVps));
    /* Other Vite plugins may populate optimizeDeps, e.g. Cypress: https://github.com/brillout/vite-plugin-ssr/issues/386
    assert(config.optimizeDeps.entries === undefined)
    */
    config.optimizeDeps.include = [...include, ...normalizeInclude(config.optimizeDeps.include)];
    config.optimizeDeps.entries = [...entries, ...normalizeEntries(config.optimizeDeps.entries)];
}
exports.determineOptimizeDeps = determineOptimizeDeps;
async function getPageDeps(config, configVps, isDev) {
    let entries = [];
    let include = [];
    // V1 design
    {
        const { pageConfigsData } = await (0, getConfigData_1.getConfigData)(config.root, isDev, configVps.extensions);
        pageConfigsData.forEach((data) => {
            Object.entries(data.configElements).forEach(([_configName, configElement]) => {
                const { codeFilePath, configEnv } = configElement;
                if (!codeFilePath)
                    return;
                if (!(configEnv === 'client-only' || configEnv === 'server-and-client'))
                    return;
                if (codeFilePath.startsWith('/')) {
                    // Is getFilePathAbsolute() really needed? This contradicts the code below that doesn't need getFilePathAbsolute().
                    entries.push((0, utils_1.getFilePathAbsolute)(codeFilePath, config));
                    return;
                }
                // getConfigData() resolves relative import paths
                (0, utils_1.assert)(!codeFilePath.startsWith('.'));
                // We need to differentiate between npm package imports and path aliases.
                // There are path aliases that cannot be distinguished from npm package names.
                // We recommend users to use the '#' prefix convention for path aliases, see https://vite-plugin-ssr.com/path-aliases#vite and assertResolveAlias()
                if ((0, utils_1.isNpmPackageImport)(codeFilePath)) {
                    // isNpmPackageImport() returns false for a path alias like #root/renderer/onRenderClient
                    (0, utils_1.assert)(!codeFilePath.startsWith('#'));
                    include.push(codeFilePath);
                }
                else {
                    /* Path aliases, e.g.:
                     * ```js
                     * // /renderer/+config.js
                     * import onRenderClient from '#root/renderer/onRenderClient'
                     * ```
                     * Does Vite resolve the path aliases or is getFilePathAbsolute() needed?
                     */
                    entries.push(codeFilePath);
                }
            });
        });
    }
    // V0.4 design
    {
        const pageFiles = await (0, findPageFiles_1.findPageFiles)(config, ['.page', '.page.client'], isDev);
        pageFiles.forEach((filePath) => {
            const entry = (0, utils_1.getFilePathAbsolute)(filePath, config);
            entries.push(entry);
        });
    }
    entries = (0, utils_1.unique)(entries);
    include = (0, utils_1.unique)(include);
    return { entries, include };
}
function getExtensionsDeps(configVps) {
    return [
        /* Doesn't work since `pageConfigsSrcDir` is a directory. We could make it work by using find-glob.
        ...configVps.extensions
          .map(({ pageConfigsSrcDir }) => pageConfigsSrcDir)
          .flat()
          .filter(isNotNullish),
        //*/
        ...configVps.extensions
            .map(({ pageConfigsDistFiles }) => pageConfigsDistFiles)
            .flat()
            .filter(utils_1.isNotNullish)
            .filter(({ importPath }) => !importPath.endsWith('.css'))
            .map(({ importPath }) => importPath)
    ];
}
function normalizeEntries(entries) {
    if (Array.isArray(entries))
        return entries;
    if (typeof entries === 'string')
        return [entries];
    if (entries === undefined)
        return [];
    (0, utils_1.assert)(false);
}
function normalizeInclude(include) {
    if (Array.isArray(include))
        return include;
    if (include === undefined)
        return [];
    (0, utils_1.assert)(false);
}
