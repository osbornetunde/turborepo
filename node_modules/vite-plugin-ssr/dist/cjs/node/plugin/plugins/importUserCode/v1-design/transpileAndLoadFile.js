"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transpileAndLoadFile = void 0;
const esbuild_1 = __importDefault(require("esbuild"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const import_1 = require("@brillout/import");
const utils_1 = require("../../../utils");
const replaceImportStatements_1 = require("./replaceImportStatements");
const getConfigData_1 = require("./getConfigData");
(0, utils_1.assertIsVitePluginCode)();
async function transpileAndLoadFile(filePath, isPageConfig) {
    const { filePathAbsolute, filePathRelativeToUserRootDir } = filePath;
    const filePathToShowToUser = filePathRelativeToUserRootDir ?? filePathAbsolute;
    (0, utils_1.assertPosixPath)(filePathAbsolute);
    getConfigData_1.getConfigData_dependenciesInvisibleToVite.add(filePathAbsolute);
    const buildResult = await buildFile(filePathAbsolute, { bundle: !isPageConfig });
    let { code } = buildResult;
    let fileImports = null;
    const isHeader = isHeaderFile(filePathAbsolute);
    if (isPageConfig || isHeader) {
        (0, utils_1.assertWarning)(isPageConfig, `${filePathToShowToUser} is a JavaScript header file (.h.js), but JavaScript header files should only be used for +config.h.js, see https://vite-plugin-ssr.com/header-file`, { onlyOnce: true, showStackTrace: false });
        const res = (0, replaceImportStatements_1.replaceImportStatements)(code, filePathToShowToUser);
        if (!res.noImportStatement) {
            if (!isHeader) {
                const filePathCorrect = appendHeaderFileExtension(filePathToShowToUser);
                /* TODO: decide what to do
                assertWarning(
                  false,
                  `Rename ${filePathToShowToUser} to ${filePathCorrect}, see https://vite-plugin-ssr.com/header-file`,
                  { onlyOnce: true, showStackTrace: false }
                )
                */
            }
            code = res.code;
            fileImports = res.fileImports;
        }
    }
    const filePathTmp = getFilePathTmp(filePathAbsolute);
    fs_1.default.writeFileSync(filePathTmp, code);
    const clean = () => fs_1.default.unlinkSync(filePathTmp);
    let fileExports = {};
    try {
        fileExports = await (0, import_1.import_)(filePathTmp);
    }
    catch (err) {
        markAsUserLandError(err);
        throw err;
    }
    finally {
        clean();
    }
    // Return a plain JavaScript object
    //  - import() returns `[Module: null prototype] { default: { onRenderClient: '...' }}`
    //  - We don't need this special object
    fileExports = { ...fileExports };
    if (fileImports) {
        (0, utils_1.assert)(filePathRelativeToUserRootDir !== undefined);
        const filePath = filePathRelativeToUserRootDir ?? filePathAbsolute;
        assertFileImports(fileImports, fileExports, filePath);
    }
    return { fileExports };
}
exports.transpileAndLoadFile = transpileAndLoadFile;
async function buildFile(filePathAbsolute, { bundle }) {
    const options = {
        platform: 'node',
        entryPoints: [filePathAbsolute],
        sourcemap: 'inline',
        write: false,
        target: ['node14.18', 'node16'],
        outfile: 'NEVER_EMITTED.js',
        logLevel: 'silent',
        format: 'esm',
        bundle,
        minify: false
    };
    if (bundle) {
        options.bundle = true;
        options.packages = 'external';
    }
    else {
        // Avoid dead-code elimination to ensure unused imports aren't removed.
        // Esbuild still sometimes removes unused imports because of TypeScript: https://github.com/evanw/esbuild/issues/3034
        options.treeShaking = false;
    }
    let result;
    try {
        result = await esbuild_1.default.build(options);
    }
    catch (err) {
        markAsUserLandError(err);
        throw err;
    }
    const { text } = result.outputFiles[0];
    return {
        code: text
    };
}
function getFilePathTmp(filePath) {
    (0, utils_1.assertPosixPath)(filePath);
    const dirname = path_1.default.posix.dirname(filePath);
    const filename = path_1.default.posix.basename(filePath);
    // Syntax with semicolon `[build:${/*...*/}]` doesn't work on Windows: https://github.com/brillout/vite-plugin-ssr/issues/800#issuecomment-1517329455
    const tag = `[build-${(0, utils_1.getRandomId)(12)}]`;
    const filePathTmp = path_1.default.posix.join(dirname, `${tag}${filename}.mjs`);
    return filePathTmp;
}
function assertFileImports(fileImports, fileExports, filePath) {
    (0, utils_1.assertDefaultExportObject)(fileExports, filePath);
    const exportedStrings = getExportedStrings(fileExports.default);
    Object.values(exportedStrings).forEach((exportVal) => {
        if (typeof exportVal !== 'string')
            return;
        if (!(0, replaceImportStatements_1.isImportData)(exportVal))
            return;
        const importDataString = exportVal;
        fileImports.forEach((fileImport) => {
            if (fileImport.importDataString === importDataString) {
                fileImport.isReExported = true;
            }
        });
    });
    const fileImportsUnused = fileImports.filter((fi) => !fi.isReExported);
    if (fileImportsUnused.length === 0)
        return;
    const importStatements = (0, utils_1.unique)(fileImportsUnused.map((fi) => fi.importStatementCode));
    const importNamesUnused = fileImportsUnused.map((fi) => picocolors_1.default.cyan(fi.importLocalName)).join(', ');
    const singular = fileImportsUnused.length === 1;
    (0, utils_1.assertWarning)(fileImportsUnused.length === 0, [
        `${filePath} imports the following:`,
        ...importStatements.map((s) => picocolors_1.default.cyan(`  ${s}`)),
        `But the import${singular ? '' : 's'} ${importNamesUnused} ${singular ? "isn't" : "aren't"} re-exported at ${picocolors_1.default.cyan('export default { ... }')} and therefore ${singular ? 'has' : 'have'} no effect, see explanation at https://vite-plugin-ssr.com/header-file`
    ].join('\n'), { onlyOnce: true, showStackTrace: false });
}
function getExportedStrings(obj) {
    const exportedStrings = [];
    Object.values(obj).forEach((val) => {
        if (typeof val === 'string') {
            exportedStrings.push(val);
        }
        else if (Array.isArray(val)) {
            val.forEach((v) => {
                if (typeof v === 'string') {
                    exportedStrings.push(v);
                }
            });
        }
    });
    return exportedStrings;
}
function isHeaderFile(filePath) {
    const basenameParts = path_1.default.posix.basename(filePath).split('.');
    return basenameParts.includes('h');
}
function appendHeaderFileExtension(filePath) {
    const basenameParts = path_1.default.posix.basename(filePath).split('.');
    basenameParts.splice(-1, 0, 'h');
    const basenameCorrect = basenameParts.join('.');
    return path_1.default.posix.join(path_1.default.posix.dirname(filePath), basenameCorrect);
}
// TODO: implement. Or remove? Is it really needed?
function isUserLandError() { }
function markAsUserLandError(err) { }
