"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConfigData_dependenciesInvisibleToVite = exports.getConfigData_invalidate = exports.getConfigData = void 0;
// TODO
//  - gracefullly handle errors in getConfigData()
//    - Remove markAsUserLandError()?
const utils_1 = require("../../../utils");
const path_1 = __importDefault(require("path"));
const configDefinitionsBuiltIn_1 = require("./getConfigData/configDefinitionsBuiltIn");
const fast_glob_1 = __importDefault(require("fast-glob"));
const filesystemRouting_1 = require("./getConfigData/filesystemRouting");
const transpileAndLoadFile_1 = require("./transpileAndLoadFile");
const replaceImportStatements_1 = require("./replaceImportStatements");
(0, utils_1.assertIsVitePluginCode)();
let configDataPromise = null;
let getConfigData_dependenciesInvisibleToVite = new Set();
exports.getConfigData_dependenciesInvisibleToVite = getConfigData_dependenciesInvisibleToVite;
const configDefinitionsBuiltInGlobal = {
    onPrerenderStart: {
        env: 'server-only'
    },
    onBeforeRoute: {
        env: '_routing-env'
    },
    prerender: {
        env: 'config-only'
    },
    extensions: { env: 'config-only' },
    disableAutoFullBuild: { env: 'config-only' },
    includeAssetsImportedByServer: { env: 'config-only' },
    baseAssets: { env: 'config-only' },
    baseServer: { env: 'config-only' }
};
function getConfigData_invalidate() {
    configDataPromise = null;
    exports.getConfigData_dependenciesInvisibleToVite = getConfigData_dependenciesInvisibleToVite = new Set();
}
exports.getConfigData_invalidate = getConfigData_invalidate;
function getConfigData(userRootDir, isDev, extensions) {
    if (!configDataPromise) {
        configDataPromise = loadConfigData(userRootDir, isDev, extensions);
    }
    return configDataPromise;
}
exports.getConfigData = getConfigData;
async function loadInterfaceFiles(userRootDir, isDev, extensions) {
    const plusFiles = await findPlusFiles(userRootDir, isDev, extensions);
    const configFiles = [];
    const valueFiles = [];
    plusFiles.forEach((f) => {
        if (extractConfigName(f.filePathRelativeToUserRootDir) === 'config') {
            configFiles.push(f);
        }
        else {
            valueFiles.push(f);
        }
    });
    let interfaceFilesByLocationId = {};
    // Config files
    await Promise.all(configFiles.map(async ({ filePathAbsolute, filePathRelativeToUserRootDir }) => {
        const configFilePath = {
            filePathAbsolute: filePathAbsolute,
            filePathRelativeToUserRootDir: filePathRelativeToUserRootDir
        };
        const { configFile, extendsConfigs } = await loadConfigFile(configFilePath, userRootDir, []);
        const interfaceFile = getInterfaceFileFromConfigFile(configFile, false);
        const locationId = (0, filesystemRouting_1.getLocationId)(filePathRelativeToUserRootDir);
        interfaceFilesByLocationId[locationId] = interfaceFilesByLocationId[locationId] ?? [];
        interfaceFilesByLocationId[locationId].push(interfaceFile);
        extendsConfigs.forEach((extendsConfig) => {
            const interfaceFile = getInterfaceFileFromConfigFile(extendsConfig, true);
            interfaceFilesByLocationId[locationId].push(interfaceFile);
        });
    }));
    // Value files
    await Promise.all(valueFiles.map(async ({ filePathAbsolute, filePathRelativeToUserRootDir }) => {
        const configNameDefault = extractConfigName(filePathRelativeToUserRootDir);
        const interfaceFile = {
            filePath: {
                filePathRelativeToUserRootDir,
                filePathAbsolute
            },
            configMap: {
                [configNameDefault]: {}
            },
            isConfigFile: false,
            isValueFile: true,
            configNameDefault
        };
        {
            // We don't have access to custom config definitions yet
            //  - We load +someCustomConifg.js later
            //  - But we do need to eagerly load +meta.js (to get all the custom config definitions)
            const configDef = getConfigDefinitionOptional(configDefinitionsBuiltIn_1.configDefinitionsBuiltIn, configNameDefault);
            if (configDef?.env === 'config-only') {
                await loadValueFile(interfaceFile, configNameDefault);
            }
        }
        {
            const locationId = (0, filesystemRouting_1.getLocationId)(filePathRelativeToUserRootDir);
            interfaceFilesByLocationId[locationId] = interfaceFilesByLocationId[locationId] ?? [];
            interfaceFilesByLocationId[locationId].push(interfaceFile);
        }
    }));
    return interfaceFilesByLocationId;
}
function getConfigDefinition(configDefinitionsRelevant, configName, definedByFile) {
    const configDef = configDefinitionsRelevant[configName];
    assertConfigExists(configName, Object.keys(configDefinitionsRelevant), definedByFile);
    (0, utils_1.assert)(configDef);
    return configDef;
}
function getConfigDefinitionOptional(configDefinitions, configName) {
    return configDefinitions[configName] ?? null;
}
async function loadValueFile(interfaceValueFile, configNameDefault) {
    const { fileExports } = await (0, transpileAndLoadFile_1.transpileAndLoadFile)(interfaceValueFile.filePath, false);
    (0, utils_1.assertDefaultExportUnknown)(fileExports, getFilePathToShowToUser(interfaceValueFile.filePath));
    Object.entries(fileExports).forEach(([configName, configValue]) => {
        if (configName === 'default') {
            configName = configNameDefault;
        }
        interfaceValueFile.configMap[configName] = { configValue };
    });
}
function getInterfaceFileFromConfigFile(configFile, isConfigExtend) {
    const { fileExports, filePath, extendsFilePaths } = configFile;
    const interfaceFile = {
        filePath,
        configMap: {},
        isConfigFile: true,
        isValueFile: false,
        isConfigExtend,
        extendsFilePaths
    };
    const interfaceFilePathToShowToUser = getFilePathToShowToUser(filePath);
    (0, utils_1.assertDefaultExportObject)(fileExports, interfaceFilePathToShowToUser);
    Object.entries(fileExports.default).forEach(([configName, configValue]) => {
        interfaceFile.configMap[configName] = { configValue };
    });
    return interfaceFile;
}
async function loadConfigData(userRootDir, isDev, extensions) {
    const interfaceFilesByLocationId = await loadInterfaceFiles(userRootDir, isDev, extensions);
    const { vikeConfig, pageConfigGlobal } = getGlobalConfigs(interfaceFilesByLocationId, userRootDir);
    const pageConfigsData = await Promise.all(Object.entries(interfaceFilesByLocationId)
        .filter(([_pageId, interfaceFiles]) => isDefiningPage(interfaceFiles))
        .map(async ([locationId]) => {
        const interfaceFilesRelevant = getInterfaceFilesRelevant(interfaceFilesByLocationId, locationId);
        const configDefinitionsRelevant = getConfigDefinitions(interfaceFilesRelevant);
        // Load value files of custom config-only configs
        await Promise.all(getInterfaceFileList(interfaceFilesRelevant).map(async (interfaceFile) => {
            if (!interfaceFile.isValueFile)
                return;
            const { configNameDefault } = interfaceFile;
            if (isGlobalConfig(configNameDefault))
                return;
            const configDef = getConfigDefinition(configDefinitionsRelevant, configNameDefault, getFilePathToShowToUser(interfaceFile.filePath));
            if (configDef.env !== 'config-only')
                return;
            const isAlreadyLoaded = interfacefileIsAlreaydLoaded(interfaceFile);
            if (isAlreadyLoaded)
                return;
            // Value files for built-in confg-only configs should have already been loaded at loadInterfaceFiles()
            (0, utils_1.assert)(!(configNameDefault in configDefinitionsBuiltIn_1.configDefinitionsBuiltIn));
            await loadValueFile(interfaceFile, configNameDefault);
        }));
        let configElements = {};
        (0, utils_1.objectEntries)(configDefinitionsRelevant)
            .filter(([configName]) => !isGlobalConfig(configName))
            .forEach(([configName, configDef]) => {
            const configElement = resolveConfigElement(configName, configDef, interfaceFilesRelevant, userRootDir);
            if (!configElement)
                return;
            configElements[configName] = configElement;
        });
        applyEffects(configElements, configDefinitionsRelevant);
        const { routeFilesystem, routeFilesystemDefinedBy, isErrorPage } = determineRouteFilesystem(locationId, configElements.filesystemRoutingRoot);
        const entry = {
            pageId: locationId,
            isErrorPage,
            routeFilesystemDefinedBy,
            routeFilesystem: isErrorPage ? null : routeFilesystem,
            configElements
        };
        return entry;
    }));
    // Show error message upon unknown config
    Object.entries(interfaceFilesByLocationId).forEach(([locationId, interfaceFiles]) => {
        const interfaceFilesRelevant = getInterfaceFilesRelevant(interfaceFilesByLocationId, locationId);
        const configDefinitionsRelevant = getConfigDefinitions(interfaceFilesRelevant);
        interfaceFiles.forEach((interfaceFile) => {
            Object.keys(interfaceFile.configMap).forEach((configName) => {
                assertConfigExists(configName, Object.keys(configDefinitionsRelevant), getFilePathToShowToUser(interfaceFile.filePath));
            });
        });
    });
    return { pageConfigsData, pageConfigGlobal, vikeConfig };
}
function interfacefileIsAlreaydLoaded(interfaceFile) {
    const configMapValues = Object.values(interfaceFile.configMap);
    const isAlreadyLoaded = configMapValues.some((conf) => 'configValue' in conf);
    if (isAlreadyLoaded) {
        (0, utils_1.assert)(configMapValues.every((conf) => 'configValue' in conf));
    }
    return isAlreadyLoaded;
}
function getInterfaceFilesRelevant(interfaceFilesByLocationId, locationIdPage) {
    const interfaceFilesRelevant = Object.fromEntries(Object.entries(interfaceFilesByLocationId)
        .filter(([locationId]) => {
        return (0, filesystemRouting_1.isInherited)(locationId, locationIdPage);
    })
        .sort(([locationId1], [locationId2]) => (0, filesystemRouting_1.sortAfterInheritanceOrder)(locationId1, locationId2, locationIdPage)));
    return interfaceFilesRelevant;
}
function getInterfaceFileList(interfaceFilesByLocationId) {
    const interfaceFiles = [];
    Object.values(interfaceFilesByLocationId).forEach((interfaceFiles_) => {
        interfaceFiles.push(...interfaceFiles_);
    });
    return interfaceFiles;
}
function getGlobalConfigs(interfaceFilesByLocationId, userRootDir) {
    const locationIds = Object.keys(interfaceFilesByLocationId);
    const interfaceFilesGlobal = Object.fromEntries(Object.entries(interfaceFilesByLocationId).filter(([locationId]) => {
        return (0, filesystemRouting_1.isGlobalLocation)(locationId, locationIds);
    }));
    // Validate that global configs live in global interface files
    {
        const interfaceFilesGlobalUserPaths = [];
        Object.entries(interfaceFilesGlobal).forEach(([locationId, interfaceFiles]) => {
            (0, utils_1.assert)((0, filesystemRouting_1.isGlobalLocation)(locationId, locationIds));
            interfaceFiles.forEach(({ filePath: { filePathRelativeToUserRootDir } }) => {
                if (filePathRelativeToUserRootDir) {
                    interfaceFilesGlobalUserPaths.push(filePathRelativeToUserRootDir);
                }
            });
        });
        Object.entries(interfaceFilesByLocationId).forEach(([locationId, interfaceFiles]) => {
            interfaceFiles.forEach((interfaceFile) => {
                Object.keys(interfaceFile.configMap).forEach((configName) => {
                    if (!(0, filesystemRouting_1.isGlobalLocation)(locationId, locationIds) && isGlobalConfig(configName)) {
                        (0, utils_1.assertUsage)(false, [
                            `${getFilePathToShowToUser(interfaceFile.filePath)} defines the config '${configName}' which is global:`,
                            interfaceFilesGlobalUserPaths.length
                                ? `define '${configName}' in ${(0, utils_1.joinEnglish)(interfaceFilesGlobalUserPaths, 'or')} instead`
                                : `create a global config (e.g. /pages/+config.js) and define '${configName}' there instead`
                        ].join(' '));
                    }
                });
            });
        });
    }
    const vikeConfig = {};
    const pageConfigGlobal = {
        onBeforeRoute: null,
        onPrerenderStart: null
    };
    (0, utils_1.objectEntries)(configDefinitionsBuiltInGlobal).forEach(([configName, configDef]) => {
        const configElement = resolveConfigElement(configName, configDef, interfaceFilesGlobal, userRootDir);
        if (!configElement)
            return;
        if ((0, utils_1.arrayIncludes)((0, utils_1.objectKeys)(pageConfigGlobal), configName)) {
            (0, utils_1.assert)(!('configValue' in configElement));
            pageConfigGlobal[configName] = configElement;
        }
        else {
            (0, utils_1.assert)('configValue' in configElement);
            if (configName === 'prerender' && typeof configElement.configValue === 'boolean')
                return;
            (0, utils_1.assertWarning)(false, `Being able to define config '${configName}' in ${configElement.configDefinedByFile} is experimental and will likely be removed. Define the config '${configName}' in vite-plugin-ssr's Vite plugin options instead.`, { onlyOnce: true, showStackTrace: false });
            vikeConfig[configName] = configElement.configValue;
        }
    });
    return { pageConfigGlobal, vikeConfig };
}
function resolveConfigElement(configName, configDef, interfaceFilesRelevant, userRootDir) {
    // interfaceFilesRelevant is sorted by sortAfterInheritanceOrder()
    for (const interfaceFiles of Object.values(interfaceFilesRelevant)) {
        const interfaceFilesDefiningConfig = interfaceFiles.filter((interfaceFile) => interfaceFile.configMap[configName]);
        if (interfaceFilesDefiningConfig.length === 0)
            continue;
        // Main resolution logic
        {
            const interfaceValueFiles = interfaceFilesDefiningConfig
                .filter((interfaceFile) => interfaceFile.isValueFile &&
                // We consider side-effect exports (e.g. `export { frontmatter }` of .mdx files) later (i.e. with less priority)
                interfaceFile.configNameDefault === configName)
                .sort(makeOrderDeterministic);
            const interfaceConfigFiles = interfaceFilesDefiningConfig
                .filter((interfaceFile) => interfaceFile.isConfigFile &&
                // We consider value from extended configs (e.g. vike-react) later (i.e. with less priority)
                !interfaceFile.isConfigExtend)
                .sort(makeOrderDeterministic);
            const interfaceValueFile = interfaceValueFiles[0];
            const interfaceConfigFile = interfaceConfigFiles[0];
            // Make this value:
            //   /pages/some-page/+someConfig.js > `export default`
            // override that value:
            //   /pages/some-page/+config > `export default { someConfig }`
            const interfaceFileWinner = interfaceValueFile ?? interfaceConfigFile;
            if (interfaceFileWinner) {
                const interfaceFilesOverriden = [...interfaceValueFiles, ...interfaceConfigFiles].filter((f) => f !== interfaceFileWinner);
                // A user-land conflict of interfaceFiles with the same locationId means that the user has superfluously defined the config twice; the user should remove such redundancy making things unnecessarily ambiguous
                warnOverridenConfigValues(interfaceFileWinner, interfaceFilesOverriden, configName, configDef, userRootDir);
                return getConfigElement(configName, interfaceFileWinner, configDef, userRootDir);
            }
        }
        // Side-effect configs such as `export { frontmatter }` in .mdx files
        {
            const interfaceValueFiles = interfaceFilesDefiningConfig.filter((interfaceFile) => interfaceFile.isValueFile);
            const interfaceValueFileSideEffect = interfaceValueFiles[0];
            if (interfaceValueFileSideEffect) {
                (0, utils_1.assert)(interfaceValueFileSideEffect.isValueFile && interfaceValueFileSideEffect.configNameDefault !== configName);
                return getConfigElement(configName, interfaceValueFileSideEffect, configDef, userRootDir);
            }
        }
        // extends
        (0, utils_1.assert)(interfaceFilesDefiningConfig.every((interfaceFile) => interfaceFile.isConfigFile && interfaceFile.isConfigExtend));
        // extended config files are already sorted by inheritance order
        const interfaceFile = interfaceFilesDefiningConfig[0];
        (0, utils_1.assert)(interfaceFile);
        return getConfigElement(configName, interfaceFile, configDef, userRootDir);
    }
    return null;
}
function makeOrderDeterministic(interfaceFile1, interfaceFile2) {
    return (0, utils_1.lowerFirst)((interfaceFile) => {
        const { filePathRelativeToUserRootDir } = interfaceFile.filePath;
        (0, utils_1.assert)(isInterfaceFileUserLand(interfaceFile));
        (0, utils_1.assert)(filePathRelativeToUserRootDir);
        return filePathRelativeToUserRootDir.length;
    })(interfaceFile1, interfaceFile2);
}
function warnOverridenConfigValues(interfaceFileWinner, interfaceFilesOverriden, configName, configDef, userRootDir) {
    interfaceFilesOverriden.forEach((interfaceFileLoser) => {
        const configElementWinner = getConfigElement(configName, interfaceFileWinner, configDef, userRootDir);
        const configElementLoser = getConfigElement(configName, interfaceFileLoser, configDef, userRootDir);
        (0, utils_1.assertWarning)(false, `${configElementLoser.configDefinedAt} overriden by ${configElementWinner.configDefinedAt}, remove one of the two`, { onlyOnce: false, showStackTrace: false });
    });
}
function isInterfaceFileUserLand(interfaceFile) {
    return (interfaceFile.isConfigFile && !interfaceFile.isConfigExtend) || interfaceFile.isValueFile;
}
function getConfigElement(configName, interfaceFile, configDef, userRootDir) {
    // TODO: rethink file paths of ConfigElement
    const configFilePath = interfaceFile.filePath.filePathRelativeToUserRootDir ?? interfaceFile.filePath.filePathAbsolute;
    const conf = interfaceFile.configMap[configName];
    (0, utils_1.assert)(conf);
    const configEnv = configDef.env;
    if (interfaceFile.isConfigFile) {
        (0, utils_1.assert)('configValue' in conf);
        const { configValue } = conf;
        const codeFile = getCodeFilePath(configValue, interfaceFile.filePath, userRootDir);
        if (codeFile) {
            const { codeFilePath, codeFileExport } = codeFile;
            const configElement = {
                plusConfigFilePath: configFilePath,
                codeFilePath,
                codeFileExport,
                configDefinedAt: getConfigDefinedAt(codeFilePath, codeFileExport),
                configDefinedByFile: codeFilePath,
                configEnv
            };
            return configElement;
        }
        else {
            const configElement = {
                plusConfigFilePath: configFilePath,
                configDefinedAt: getConfigDefinedAt(configFilePath, configName, true),
                configDefinedByFile: configFilePath,
                codeFilePath: null,
                codeFileExport: null,
                configEnv,
                configValue
            };
            return configElement;
        }
    }
    else if (interfaceFile.isValueFile) {
        // TODO: rethink file paths of ConfigElement
        const codeFilePath = interfaceFile.filePath.filePathRelativeToUserRootDir ?? interfaceFile.filePath.filePathAbsolute;
        const codeFileExport = configName === interfaceFile.configNameDefault ? 'default' : configName;
        const configElement = {
            configEnv,
            codeFilePath,
            codeFileExport,
            plusConfigFilePath: null,
            configDefinedAt: getConfigDefinedAt(codeFilePath, codeFileExport),
            configDefinedByFile: codeFilePath
        };
        if ('configValue' in conf) {
            configElement.configValue = conf.configValue;
        }
        else {
            (0, utils_1.assert)(configEnv !== 'config-only');
        }
        return configElement;
    }
    (0, utils_1.assert)(false);
}
/* Use the type once we moved all dist/ to ESM
type ConfigDefinedAt = ReturnType<typeof getConfigDefinedAt>
*/
function getConfigDefinedAt(filePath, exportName, isDefaultExportObject) {
    if (isDefaultExportObject) {
        (0, utils_1.assert)(exportName !== 'default');
        return `${filePath} > \`export default { ${exportName} }`;
    }
    else {
        if (exportName === 'default') {
            return `${filePath} > \`export default\``;
        }
        else {
            return `${filePath} > \`export { ${exportName} }\``;
        }
    }
}
function isDefiningPage(interfaceFiles) {
    for (const interfaceFile of interfaceFiles) {
        const configNames = Object.keys(interfaceFile.configMap);
        if (configNames.some((configName) => isDefiningPageConfig(configName))) {
            return true;
        }
    }
    return false;
}
function isDefiningPageConfig(configName) {
    return ['Page', 'route'].includes(configName);
}
function getCodeFilePath(configValue, configFilePath, userRootDir) {
    if (typeof configValue !== 'string') {
        return null;
    }
    const importData = (0, replaceImportStatements_1.parseImportData)(configValue);
    if (!importData) {
        return null;
    }
    const { importPath, importExportName } = importData;
    let codeFilePath = importPath;
    if (codeFilePath.startsWith('.')) {
        // We need to resolve relative paths into absolute paths. Because the import paths are included in virtual files:
        // ```
        // [vite] Internal server error: Failed to resolve import "./onPageTransitionHooks" from "virtual:vite-plugin-ssr:importPageCode:client:/pages/index". Does the file exist?
        // ```
        codeFilePath = resolveRelativeCodeFilePath(importData, configFilePath, userRootDir);
    }
    else {
        // codeFilePath can be:
        //  - an npm package import
        //  - a path alias
    }
    return {
        // TODO: rename?
        codeFilePath,
        codeFileExport: importExportName
    };
}
function resolveRelativeCodeFilePath(importData, configFilePath, userRootDir) {
    let codeFilePath = resolveImport(importData, configFilePath);
    // Make it a Vite path
    (0, utils_1.assertPosixPath)(userRootDir);
    (0, utils_1.assertPosixPath)(codeFilePath);
    if (codeFilePath.startsWith(userRootDir)) {
        codeFilePath = getVitePathFromAbsolutePath(codeFilePath, userRootDir);
    }
    else {
        (0, utils_1.assertUsage)(false, `${getFilePathToShowToUser(configFilePath)} imports from a relative path '${importData.importPath}' outside of ${userRootDir} which is forbidden: import from a relative path inside ${userRootDir}, or import from a dependency's package.json#exports entry instead`);
        // None of the following works. Seems to be a Vite bug?
        // /*
        // assert(codeFilePath.startsWith('/'))
        // codeFilePath = `/@fs${codeFilePath}`
        // /*/
        // codeFilePath = path.posix.relative(userRootDir, codeFilePath)
        // assert(codeFilePath.startsWith('../'))
        // codeFilePath = '/' + codeFilePath
        // //*/
    }
    (0, utils_1.assertPosixPath)(codeFilePath);
    (0, utils_1.assert)(codeFilePath.startsWith('/'));
    return codeFilePath;
}
function getVitePathFromAbsolutePath(filePathAbsolute, root) {
    (0, utils_1.assertPosixPath)(filePathAbsolute);
    (0, utils_1.assertPosixPath)(root);
    (0, utils_1.assert)(filePathAbsolute.startsWith(root));
    let vitePath = path_1.default.posix.relative(root, filePathAbsolute);
    (0, utils_1.assert)(!vitePath.startsWith('/') && !vitePath.startsWith('.'));
    vitePath = '/' + vitePath;
    return vitePath;
}
function getConfigDefinitions(interfaceFilesRelevant) {
    const configDefinitions = { ...configDefinitionsBuiltIn_1.configDefinitionsBuiltIn };
    Object.values(interfaceFilesRelevant).forEach((interfaceFiles) => {
        const configEntry = getConfigEntry('meta', interfaceFiles);
        if (!configEntry.configIsDefined)
            return;
        (0, utils_1.assert)('configValue' in configEntry);
        const metaVal = configEntry.configValue;
        const { interfaceFile } = configEntry;
        assertMetaValue(metaVal, getFilePathToShowToUser(interfaceFile.filePath));
        (0, utils_1.objectEntries)(metaVal).forEach(([configName, configDefinition]) => {
            // User can override an existing config definition
            configDefinitions[configName] = {
                ...configDefinitions[configName],
                ...configDefinition
            };
        });
    });
    return configDefinitions;
}
function getConfigEntry(configName, interfaceFiles) {
    const interfaceFilesForConfig = interfaceFiles.filter((interfaceFile) => configName in interfaceFile.configMap);
    if (interfaceFilesForConfig.length === 0)
        return { configIsDefined: false };
    const interfaceFile = interfaceFilesForConfig[0];
    const val = interfaceFile.configMap[configName];
    (0, utils_1.assert)(val);
    return { configIsDefined: true, interfaceFile, ...val };
}
function assertMetaValue(metaVal, definedByFile) {
    (0, utils_1.assertUsage)((0, utils_1.isObject)(metaVal), `${definedByFile} sets the config 'meta' to a value with an invalid type \`${typeof metaVal}\`: it should be an object instead.`);
    (0, utils_1.objectEntries)(metaVal).forEach(([configName, def]) => {
        (0, utils_1.assertUsage)((0, utils_1.isObject)(def), `${definedByFile} sets meta.${configName} to a value with an invalid type \`${typeof def}\`: it should be an object instead.`);
        // env
        {
            const envValues = ['client-only', 'server-only', 'server-and-client', 'config-only'];
            const hint = [
                'Set the value of `env` to ',
                (0, utils_1.joinEnglish)(envValues.map((s) => `'${s}'`), 'or'),
                '.'
            ].join('');
            (0, utils_1.assertUsage)('env' in def, `${definedByFile} doesn't set meta.${configName}.env but it's required. ${hint}`);
            (0, utils_1.assertUsage)((0, utils_1.hasProp)(def, 'env', 'string'), `${definedByFile} > meta.${configName}.env has an invalid type \`${typeof def.env}\`. ${hint}`);
            (0, utils_1.assertUsage)(envValues.includes(def.env), `${definedByFile} > meta.${configName}.env has an invalid value '${def.env}'. ${hint}`);
        }
        // effect
        if ('effect' in def) {
            (0, utils_1.assertUsage)((0, utils_1.hasProp)(def, 'effect', 'function'), `${definedByFile} > meta.${configName}.effect has an invalid type \`${typeof def.effect}\`: it should be a function instead`);
            (0, utils_1.assertUsage)(def.env === 'config-only', `${definedByFile} > meta.${configName}.effect is only supported if meta.${configName}.env is 'config-only' (but it's '${def.env}')`);
        }
    });
}
function applyEffects(configElements, configDefinitionsRelevant) {
    (0, utils_1.objectEntries)(configDefinitionsRelevant).forEach(([configName, configDef]) => {
        if (!configDef.effect)
            return;
        (0, utils_1.assert)(configDef.env === 'config-only');
        const configElement = configElements[configName];
        if (!configElement)
            return;
        (0, utils_1.assert)('configValue' in configElement);
        const { configValue, configDefinedAt } = configElement;
        const configFromEffect = configDef.effect({
            configValue,
            configDefinedAt
        });
        if (!configFromEffect)
            return;
        applyEffect(configFromEffect, configElement, configElements, configDefinitionsRelevant);
    });
}
function applyEffect(configFromEffect, configElement, configElements, configDefinitionsRelevant) {
    const configDefinedAtWithEffect = `${configElement.configDefinedAt} > effect()`;
    (0, utils_1.objectEntries)(configFromEffect).forEach(([configName, configValue]) => {
        if (configName === 'meta') {
            assertMetaValue(configValue, configDefinedAtWithEffect);
            (0, utils_1.objectEntries)(configValue).forEach(([configTargetName, configTargetDef]) => {
                const keys = Object.keys(configTargetDef);
                (0, utils_1.assert)(keys.includes('env'));
                (0, utils_1.assert)(keys.length === 1);
                const configTargetElement = configElements[configTargetName];
                if (configTargetElement) {
                    configTargetElement.configEnv = configTargetDef.env;
                }
            });
        }
        else {
            // AFAIK we don't use this, nor do we need it?
            (0, utils_1.assertWarning)(false, `${configDefinedAtWithEffect} is modifying a config value; this is an experimental functionality; reach out to a maintainer if you want to use this in production`, { onlyOnce: true, showStackTrace: false });
            /* We're completely overriding any previous configElement
            const configElementTargetOriginal = configElements[configName]
            */
            const configDef = getConfigDefinition(configDefinitionsRelevant, configName, configDefinedAtWithEffect);
            configElements[configName] = {
                configValue,
                configEnv: configDef.env,
                ...getConfigElementSource(configElement),
                configDefinedAt: configDefinedAtWithEffect,
                configDefinedByFile: configElement.configDefinedByFile
            };
        }
    });
}
function getConfigElementSource(configElement) {
    const { plusConfigFilePath, codeFilePath, codeFileExport } = configElement;
    const configElementSource = { plusConfigFilePath, codeFilePath, codeFileExport };
    return configElementSource;
}
async function findPlusFiles(userRootDir, isDev, extensions) {
    const plusFiles = await findUserFiles(`**/+*.${utils_1.scriptFileExtensions}`, userRootDir, isDev);
    extensions.forEach((extension) => {
        extension.pageConfigsDistFiles?.forEach((pageConfigDistFile) => {
            // TODO/v1-release: remove
            if (!pageConfigDistFile.importPath.includes('+'))
                return;
            (0, utils_1.assert)(pageConfigDistFile.importPath.includes('+'));
            (0, utils_1.assert)(path_1.default.posix.basename(pageConfigDistFile.importPath).startsWith('+'));
            const { importPath, filePath } = pageConfigDistFile;
            plusFiles.push({
                filePathRelativeToUserRootDir: importPath,
                filePathAbsolute: filePath
            });
        });
    });
    return plusFiles;
}
function extractConfigName(filePath) {
    (0, utils_1.assertPosixPath)(filePath);
    const basename = path_1.default.posix.basename(filePath).split('.')[0];
    (0, utils_1.assert)(basename.startsWith('+'));
    const configName = basename.slice(1);
    return configName;
}
async function loadConfigFile(configFilePath, userRootDir, visited) {
    const { filePathAbsolute, filePathRelativeToUserRootDir } = configFilePath;
    assertNoInfiniteLoop(visited, filePathAbsolute);
    const { fileExports } = await (0, transpileAndLoadFile_1.transpileAndLoadFile)(configFilePath, true);
    const { extendsConfigs, extendsFilePaths } = await loadExtendsConfigs(fileExports, configFilePath, userRootDir, [
        ...visited,
        filePathAbsolute
    ]);
    const configFile = {
        fileExports,
        filePath: {
            filePathRelativeToUserRootDir,
            filePathAbsolute
        },
        extendsFilePaths
    };
    return { configFile, extendsConfigs };
}
function assertNoInfiniteLoop(visited, filePathAbsolute) {
    const idx = visited.indexOf(filePathAbsolute);
    if (idx === -1)
        return;
    const loop = visited.slice(idx);
    (0, utils_1.assert)(loop[0] === filePathAbsolute);
    (0, utils_1.assertUsage)(idx === -1, `Infinite extends loop ${[...loop, filePathAbsolute].join('>')}`);
}
async function loadExtendsConfigs(configFileExports, configFilePath, userRootDir, visited) {
    const extendsImportData = getExtendsImportData(configFileExports, configFilePath);
    const extendsConfigFiles = [];
    extendsImportData.map((importData) => {
        const { importPath } = importData;
        // TODO
        //  - validate extends configs
        const filePathAbsolute = resolveImport(importData, configFilePath);
        assertExtendsImportPath(importPath, filePathAbsolute, configFilePath);
        extendsConfigFiles.push({
            filePathAbsolute,
            // - filePathRelativeToUserRootDir has no functionality beyond nicer error messages for user
            // - Using importPath would be visually nicer but it's ambigous => we rather pick filePathAbsolute for added clarity
            filePathRelativeToUserRootDir: determineFilePathRelativeToUserDir(filePathAbsolute, userRootDir)
        });
    });
    const extendsConfigs = [];
    await Promise.all(extendsConfigFiles.map(async (configFilePath) => {
        const result = await loadConfigFile(configFilePath, userRootDir, visited);
        extendsConfigs.push(result.configFile);
        extendsConfigs.push(...result.extendsConfigs);
    }));
    const extendsFilePaths = extendsConfigFiles.map((f) => f.filePathAbsolute);
    return { extendsConfigs, extendsFilePaths };
}
function determineFilePathRelativeToUserDir(filePathAbsolute, userRootDir) {
    (0, utils_1.assertPosixPath)(filePathAbsolute);
    (0, utils_1.assertPosixPath)(userRootDir);
    if (!filePathAbsolute.startsWith(userRootDir)) {
        return null;
    }
    let filePathRelativeToUserRootDir = filePathAbsolute.slice(userRootDir.length);
    if (!filePathRelativeToUserRootDir.startsWith('/'))
        filePathRelativeToUserRootDir = '/' + filePathRelativeToUserRootDir;
    return filePathRelativeToUserRootDir;
}
function assertExtendsImportPath(importPath, filePath, configFilePath) {
    if ((0, utils_1.isNpmPackageImport)(importPath)) {
        const fileDir = path_1.default.posix.dirname(filePath) + '/';
        const fileName = path_1.default.posix.basename(filePath);
        const fileNameBaseCorrect = '+config';
        const [fileNameBase, ...fileNameRest] = fileName.split('.');
        const fileNameCorrect = [fileNameBaseCorrect, ...fileNameRest].join('.');
        (0, utils_1.assertWarning)(fileNameBase === fileNameBaseCorrect, `Rename ${fileName} to ${fileNameCorrect} in ${fileDir}`, {
            onlyOnce: true,
            showStackTrace: false
        });
    }
    else {
        (0, utils_1.assertWarning)(false, `${getFilePathToShowToUser(configFilePath)} uses 'extends' to inherit from '${importPath}' which is a user-land file: this is experimental and may be remove at any time. Reach out to a maintainer if you need this feature.`, { onlyOnce: true, showStackTrace: false });
    }
}
function getFilePathToShowToUser(filePath) {
    const filePathToShowToUser = filePath.filePathRelativeToUserRootDir ?? filePath.filePathAbsolute;
    (0, utils_1.assert)(filePathToShowToUser);
    return filePathToShowToUser;
}
function getExtendsImportData(configFileExports, configFilePath) {
    const filePathToShowToUser = getFilePathToShowToUser(configFilePath);
    (0, utils_1.assertDefaultExportObject)(configFileExports, filePathToShowToUser);
    const configValues = configFileExports.default;
    const wrongUsage = `${filePathToShowToUser} set the config 'extends' to an invalid value, see https://vite-plugin-ssr.com/extends`;
    let extendList;
    if (!('extends' in configValues)) {
        return [];
    }
    else if ((0, utils_1.hasProp)(configValues, 'extends', 'string')) {
        extendList = [configValues.extends];
    }
    else if ((0, utils_1.hasProp)(configValues, 'extends', 'string[]')) {
        extendList = configValues.extends;
    }
    else {
        (0, utils_1.assertUsage)(false, wrongUsage);
    }
    const extendsImportData = extendList.map((importDataSerialized) => {
        const importData = (0, replaceImportStatements_1.parseImportData)(importDataSerialized);
        (0, utils_1.assertUsage)(importData, wrongUsage);
        return importData;
    });
    return extendsImportData;
}
async function findUserFiles(pattern, userRootDir, isDev) {
    (0, utils_1.assertPosixPath)(userRootDir);
    const timeBase = new Date().getTime();
    const result = await (0, fast_glob_1.default)(pattern, {
        ignore: ['**/node_modules/**'],
        cwd: userRootDir,
        dot: false
    });
    const time = new Date().getTime() - timeBase;
    if (isDev) {
        // We only warn in dev, because while building it's expected to take a long time as fast-glob is competing for resources with other tasks
        (0, utils_1.assertWarning)(time < 2 * 1000, `Crawling your user files took an unexpected long time (${time}ms). Create a new issue on vite-plugin-ssr's GitHub.`, {
            showStackTrace: false,
            onlyOnce: 'slow-page-files-search'
        });
    }
    const userFiles = result.map((p) => {
        p = (0, utils_1.toPosixPath)(p);
        const filePathRelativeToUserRootDir = path_1.default.posix.join('/', p);
        const filePathAbsolute = path_1.default.posix.join(userRootDir, p);
        return { filePathRelativeToUserRootDir, filePathAbsolute };
    });
    return userFiles;
}
// TODO: re-use this
function handleUserFileError(err, isDev) {
    // Properly handle error during transpilation so that we can use assertUsage() during transpilation
    if (isDev) {
        throw err;
    }
    else {
        // Avoid ugly error format:
        // ```
        // [vite-plugin-ssr:importUserCode] Could not load virtual:vite-plugin-ssr:importUserCode:server: [vite-plugin-ssr@0.4.70][Wrong Usage] /pages/+config.ts sets the config 'onRenderHtml' to the value './+config/onRenderHtml-i-dont-exist.js' but no file was found at /home/rom/code/vite-plugin-ssr/examples/v1/pages/+config/onRenderHtml-i-dont-exist.js
        // Error: [vite-plugin-ssr@0.4.70][Wrong Usage] /pages/+config.ts sets the config 'onRenderHtml' to the value './+config/onRenderHtml-i-dont-exist.js' but no file was found at /home/rom/code/vite-plugin-ssr/examples/v1/pages/+config/onRenderHtml-i-dont-exist.js
        //     at ...
        //     at ...
        //     at ...
        //     at ...
        //     at ...
        //     at ...
        //   code: 'PLUGIN_ERROR',
        //   plugin: 'vite-plugin-ssr:importUserCode',
        //   hook: 'load',
        //   watchFiles: [
        //     '/home/rom/code/vite-plugin-ssr/vite-plugin-ssr/dist/cjs/node/importBuild.js',
        //     '\x00virtual:vite-plugin-ssr:importUserCode:server'
        //   ]
        // }
        //  ELIFECYCLE  Command failed with exit code 1.
        // ```
        console.log('');
        console.error(err);
        process.exit(1);
    }
}
function isGlobalConfig(configName) {
    if (configName === 'prerender')
        return false;
    const configNamesGlobal = Object.keys(configDefinitionsBuiltInGlobal);
    return (0, utils_1.arrayIncludes)(configNamesGlobal, configName);
}
function assertConfigExists(configName, configsDefined, definedByFile) {
    if (isGlobalConfig(configName))
        return;
    if (configsDefined.includes(configName))
        return;
    let errMsg = `${definedByFile} defines an unknown config '${configName}'`;
    const configNameSimilar = (0, utils_1.getMostSimilar)(configName, configsDefined);
    if (configNameSimilar) {
        (0, utils_1.assert)(configNameSimilar !== configName);
        errMsg = `${errMsg}, did you mean to define '${configNameSimilar}' instead?`;
    }
    (0, utils_1.assertUsage)(false, errMsg);
}
function determineRouteFilesystem(locationId, configFilesystemRoutingRoot) {
    let routeFilesystem = (0, filesystemRouting_1.getRouteFilesystem)(locationId);
    if (determineIsErrorPage(routeFilesystem)) {
        return { isErrorPage: true, routeFilesystem: null, routeFilesystemDefinedBy: null };
    }
    let routeFilesystemDefinedBy = (0, filesystemRouting_1.getRouteFilesystemDefinedBy)(locationId); // for log404()
    if (configFilesystemRoutingRoot) {
        const routingRoot = getFilesystemRoutingRootEffect(configFilesystemRoutingRoot);
        if (routingRoot) {
            const { filesystemRoutingRootEffect, filesystemRoutingRootDefinedAt } = routingRoot;
            const debugInfo = { locationId, routeFilesystem, configFilesystemRoutingRoot };
            (0, utils_1.assert)(routeFilesystem.startsWith(filesystemRoutingRootEffect.before), debugInfo);
            routeFilesystem = (0, filesystemRouting_1.applyFilesystemRoutingRootEffect)(routeFilesystem, filesystemRoutingRootEffect);
            (0, utils_1.assert)(filesystemRoutingRootDefinedAt.includes('export'));
            routeFilesystemDefinedBy = `${routeFilesystemDefinedBy} (with ${filesystemRoutingRootDefinedAt})`;
        }
    }
    (0, utils_1.assert)(routeFilesystem.startsWith('/'));
    return { routeFilesystem, routeFilesystemDefinedBy, isErrorPage: false };
}
function getFilesystemRoutingRootEffect(configFilesystemRoutingRoot) {
    (0, utils_1.assert)(configFilesystemRoutingRoot.configEnv === 'config-only');
    // Eagerly loaded since it's config-only
    (0, utils_1.assert)('configValue' in configFilesystemRoutingRoot);
    const { configValue } = configFilesystemRoutingRoot;
    (0, utils_1.assertUsage)(typeof configValue === 'string', `${configFilesystemRoutingRoot.configDefinedAt} should be a string`);
    const { configDefinedAt } = configFilesystemRoutingRoot;
    (0, utils_1.assertUsage)(configValue.startsWith('/'), `${configDefinedAt} is '${configValue}' but it should start with a leading slash '/'`);
    const { configDefinedByFile } = configFilesystemRoutingRoot;
    const before = (0, filesystemRouting_1.getRouteFilesystem)((0, filesystemRouting_1.getLocationId)(configDefinedByFile));
    const after = configValue;
    const filesystemRoutingRootEffect = { before, after };
    return { filesystemRoutingRootEffect, filesystemRoutingRootDefinedAt: configDefinedAt };
}
function determineIsErrorPage(routeFilesystem) {
    (0, utils_1.assertPosixPath)(routeFilesystem);
    return routeFilesystem.split('/').includes('_error');
}
function resolveImport(importData, importerFilePath) {
    const { filePathAbsolute } = importerFilePath;
    (0, utils_1.assertPosixPath)(filePathAbsolute);
    let plusConfigFilDirPathAbsolute = path_1.default.posix.dirname(filePathAbsolute);
    const clean = (0, utils_1.addFileExtensionsToRequireResolve)();
    let importedFile;
    try {
        importedFile = require.resolve(importData.importPath, { paths: [plusConfigFilDirPathAbsolute] });
    }
    catch {
        importedFile = null;
    }
    finally {
        clean();
    }
    assertImport(importedFile, importData, importerFilePath);
    importedFile = (0, utils_1.toPosixPath)(importedFile);
    return importedFile;
}
function assertImport(importedFile, importData, importerFilePath) {
    const { importPath, importWasGenerated, importDataString } = importData;
    const filePathToShowToUser = getFilePathToShowToUser(importerFilePath);
    if (!importedFile) {
        const errIntro = importWasGenerated
            ? `The import '${importPath}' in ${filePathToShowToUser}`
            : `'${importDataString}' defined in ${filePathToShowToUser}`;
        const errIntro2 = `${errIntro} couldn't be resolved: does '${importPath}'`;
        if (importPath.startsWith('.')) {
            (0, utils_1.assertUsage)(false, `${errIntro2} point to an existing file?`);
        }
        else {
            (0, utils_1.assertUsage)(false, `${errIntro2} exist?`);
        }
    }
}
