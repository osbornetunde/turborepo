"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addSsrMiddleware = void 0;
const renderPage_1 = require("../../runtime/renderPage");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const utils_1 = require("../utils");
let isErrorPrevious;
let msgPrev;
const zeroWidthSpace = '\u200b';
function addSsrMiddleware(middlewares, viteDevServer) {
    middlewares.use(async (req, res, next) => {
        if (res.headersSent)
            return next();
        const url = req.originalUrl || req.url;
        if (!url)
            return next();
        const userAgent = req.headers['user-agent'];
        const onRenderResult = (isError, statusCode) => {
            onRenderResultCallback(isError, statusCode, url, viteDevServer);
        };
        const pageContextInit = {
            urlOriginal: url,
            userAgent,
            _onRenderResult: onRenderResult
        };
        let pageContext;
        try {
            pageContext = await (0, renderPage_1.renderPage)(pageContextInit);
        }
        catch (err) {
            // Throwing an error in a connect middleware shut downs the server
            console.error(err);
            // - next(err) automatically uses buildErrorMessage() (pretty formatting of Rollup errors)
            //   - But it only works for users using Vite's standalone dev server (it doesn't work for users using Vite's dev middleware)
            // - We purposely don't use next(err) to align behavior: we use our own/copied implementation of buildErrorMessage() regardless of whether the user uses Vite's dev middleware or Vite's standalone dev server
            return next();
        }
        if (!pageContext.httpResponse)
            return next();
        const { statusCode, contentType } = pageContext.httpResponse;
        res.setHeader('Content-Type', contentType);
        res.statusCode = statusCode;
        pageContext.httpResponse.pipe(res);
    });
}
exports.addSsrMiddleware = addSsrMiddleware;
function onRenderResultCallback(isError, statusCode, url, viteDevServer) {
    if (!viteDevServer)
        return;
    (0, utils_1.assert)(typeof isError === 'boolean');
    (0, utils_1.assert)(statusCode === null || statusCode === 200 || statusCode === 404);
    const color = (s) => picocolors_1.default.bold(isError ? picocolors_1.default.red(s) : picocolors_1.default.green(s));
    const msg = [picocolors_1.default.green('HTTP Request'), color(statusCode || 'ERR'), picocolors_1.default.gray(url)].join(' ');
    const clear = isError || isErrorPrevious === true;
    isErrorPrevious = isError;
    log(msg, viteDevServer, clear);
}
// Copied and adapted from https://github.com/vitejs/vite/blob/9adb2a3a29e26302647092d783ea78cff6ca3473/packages/vite/src/node/logger.ts
function log(msg, viteDevServer, clear) {
    const tag = picocolors_1.default.cyan(picocolors_1.default.bold(`[${utils_1.projectInfo.projectName}]`));
    // Workaround for Vite not respecting the clear option: https://github.com/vitejs/vite/blob/02a46d7ceab71ebf7ba723372ba37012b7f9ccaf/packages/vite/src/node/logger.ts#L91
    // We need to avoid clearing so that VPS warnings aren't hidden from users
    if (!clear)
        msg = addStringIsEqualBuster(msg);
    viteDevServer.config.logger.info(`${picocolors_1.default.dim(new Date().toLocaleTimeString())} ${tag} ${msg}`, { clear });
}
function addStringIsEqualBuster(msg) {
    if (!process.stdout.isTTY || process.env.CI) {
        // Workaround isn't needed: https://github.com/vitejs/vite/blob/02a46d7ceab71ebf7ba723372ba37012b7f9ccaf/packages/vite/src/node/logger.ts#L65-L66
        return msg;
    }
    if (msgPrev === msg) {
        msg = msg + zeroWidthSpace;
    }
    msgPrev = msg;
    return msg;
}
