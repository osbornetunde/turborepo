"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.callHookWithTimeout = void 0;
const assert_1 = require("./assert");
const humanizeTime_1 = require("./humanizeTime");
function callHookWithTimeout(hookFn, hookName, hookFilePath) {
    const { timeoutErr, timeoutWarn } = getTimeouts(hookName);
    let resolve;
    let reject;
    const promise = new Promise((resolve_, reject_) => {
        resolve = (ret) => {
            clearTimeouts();
            resolve_(ret);
        };
        reject = (err) => {
            clearTimeouts();
            reject_(err);
        };
    });
    const clearTimeouts = () => {
        clearTimeout(t1);
        clearTimeout(t2);
    };
    const t1 = setTimeout(() => {
        const msg = `${assert_1.logPrefix}[Warning] The ${hookName}() hook defined by ${hookFilePath} is taking more than ${(0, humanizeTime_1.humanizeTime)(timeoutWarn)}`;
        console.warn(msg);
    }, timeoutWarn);
    const t2 = setTimeout(() => {
        const err = (0, assert_1.getProjectError)(`Hook timeout: the ${hookName}() hook defined by ${hookFilePath} didn't finish after ${(0, humanizeTime_1.humanizeTime)(timeoutErr)}`);
        reject(err);
    }, timeoutErr);
    (async () => {
        try {
            const ret = await hookFn();
            resolve(ret);
        }
        catch (err) {
            reject(err);
        }
    })();
    return promise;
}
exports.callHookWithTimeout = callHookWithTimeout;
function getTimeouts(hookName) {
    let timeoutErr = 40 * 1000;
    let timeoutWarn = 4 * 1000;
    if (hookName === 'onBeforeRoute') {
        timeoutErr = 5 * 1000;
        timeoutWarn = 1 * 1000;
    }
    if (hookName === 'onBeforePrerender') {
        timeoutErr = 10 * 60 * 1000;
        timeoutWarn = 30 * 1000;
    }
    return { timeoutErr, timeoutWarn };
}
