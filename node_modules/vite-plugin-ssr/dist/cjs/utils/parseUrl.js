"use strict";
// Unit tests at ./parseUrl.spec.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.isBaseAssets = exports.isBaseServer = exports.normalizeBaseServer = exports.assertUsageUrl = exports.assertUsageBaseServer = exports.prependBase = exports.isParsable = exports.parseUrl = void 0;
const slice_1 = require("./slice");
const assert_1 = require("./assert");
function isParsable(url) {
    // `parseUrl()` works with these URLs
    return (url.startsWith('/') ||
        url.startsWith('http') ||
        url.startsWith('tauri://') ||
        url.startsWith('.') ||
        url.startsWith('?') ||
        url.startsWith('#') ||
        url === '');
}
exports.isParsable = isParsable;
function assertUsageUrl(url, errPrefix) {
    (0, assert_1.assert)(errPrefix.includes(' but '));
    (0, assert_1.assertUsage)(typeof url === 'string', `${errPrefix} should be a string`);
    if (isParsable(url))
        return;
    if (!url.startsWith('/') && !url.includes(':')) {
        (0, assert_1.assertUsage)(false, `${errPrefix} is '${url}' and it should be '/${url}' instead (URL pathnames should start with a leading slash)`);
    }
    else {
        (0, assert_1.assertUsage)(false, `${errPrefix} isn't a valid URL`);
    }
}
exports.assertUsageUrl = assertUsageUrl;
function parseUrl(url, baseServer) {
    (0, assert_1.assert)(isParsable(url), { url });
    (0, assert_1.assert)(baseServer.startsWith('/'), { url, baseServer });
    // Hash
    const [urlWithoutHash, ...hashList] = url.split('#');
    (0, assert_1.assert)(urlWithoutHash !== undefined);
    const hashOriginal = ['', ...hashList].join('#') || null;
    (0, assert_1.assert)(hashOriginal === null || hashOriginal.startsWith('#'));
    const hash = hashOriginal === null ? '' : decodeSafe(hashOriginal.slice(1));
    // Search
    const [urlWithoutSearch, ...searchList] = urlWithoutHash.split('?');
    (0, assert_1.assert)(urlWithoutSearch !== undefined);
    const searchOriginal = ['', ...searchList].join('?') || null;
    (0, assert_1.assert)(searchOriginal === null || searchOriginal.startsWith('?'), { url, searchOriginal });
    const search = {};
    const searchAll = {};
    Array.from(new URLSearchParams(searchOriginal || '')).forEach(([key, val]) => {
        search[key] = val;
        searchAll[key] = [...(searchAll[key] || []), val];
    });
    // Origin + pathname
    const { origin, pathnameResolved } = parseWithNewUrl(urlWithoutSearch, baseServer);
    (0, assert_1.assert)(origin === null || origin === decodeSafe(origin), { origin }); // AFAICT decoding the origin is useless
    (0, assert_1.assert)(pathnameResolved.startsWith('/'), { url, pathnameResolved });
    (0, assert_1.assert)(origin === null || url.startsWith(origin), { url, origin });
    // `pathnameOriginal`
    const pathnameOriginal = urlWithoutSearch.slice((origin || '').length);
    {
        const urlRecreated = `${origin || ''}${pathnameOriginal}${searchOriginal || ''}${hashOriginal || ''}`;
        (0, assert_1.assert)(url === urlRecreated, { url, urlRecreated });
    }
    // Base URL
    let { pathname, hasBaseServer } = analyzeBaseServer(pathnameResolved, baseServer);
    pathname = decodePathname(pathname);
    (0, assert_1.assert)(pathname.startsWith('/'));
    return {
        origin,
        pathname,
        pathnameOriginal: pathnameOriginal,
        hasBaseServer,
        search,
        searchAll,
        searchOriginal,
        hash,
        hashOriginal
    };
}
exports.parseUrl = parseUrl;
function decodeSafe(urlComponent) {
    try {
        return decodeURIComponent(urlComponent);
    }
    catch { }
    try {
        return decodeURI(urlComponent);
    }
    catch { }
    return urlComponent;
}
function decodePathname(urlPathname) {
    return urlPathname
        .split('/')
        .map((dir) => decodeSafe(dir).split('/').join('%2F'))
        .join('/');
}
function parseWithNewUrl(urlWithoutSearch, baseServer) {
    // `new URL('//', 'https://example.org')` throws `ERR_INVALID_URL`
    if (urlWithoutSearch.startsWith('//')) {
        return { origin: null, pathnameResolved: urlWithoutSearch };
    }
    let isTauriProtocol = false;
    const PROTOCOL_TAURI = 'tauri://';
    const PROTOCOL_FAKE = 'http://';
    if (urlWithoutSearch.startsWith(PROTOCOL_TAURI)) {
        isTauriProtocol = true;
        urlWithoutSearch = PROTOCOL_FAKE + urlWithoutSearch.slice(PROTOCOL_TAURI.length);
    }
    let origin;
    let pathnameResolved;
    try {
        // `new URL(url)` throws an error if `url` doesn't have an origin
        const urlParsed = new URL(urlWithoutSearch);
        origin = urlParsed.origin;
        pathnameResolved = urlParsed.pathname;
    }
    catch (err) {
        // `url` has no origin
        origin = null;
        // In the browser, this is the Base URL of the current URL
        let base = typeof window !== 'undefined' &&
            // We need to access safely in case the user sets `window` in Node.js
            window?.document?.baseURI;
        base = base || 'http://fake.example.org' + baseServer;
        // `new Url()` supports:
        //  - `url === '/absolute/path'`
        //  - `url === './relative/path'`
        //  - `url === '?queryWithoutPath'`
        //  - `url === '''`
        // `base` in `new URL(url, base)` is used for resolving relative paths (`new URL()` doesn't remove `base` from `pathname`)
        const urlParsed = new URL(urlWithoutSearch, base);
        pathnameResolved = urlParsed.pathname;
    }
    if (!pathnameResolved)
        pathnameResolved = '/';
    if (isTauriProtocol) {
        (0, assert_1.assert)(origin);
        (0, assert_1.assert)(origin.startsWith(PROTOCOL_FAKE));
        origin = PROTOCOL_TAURI + origin.slice(PROTOCOL_FAKE.length);
    }
    (0, assert_1.assert)(pathnameResolved.startsWith('/'), { urlWithoutSearch, pathnameResolved });
    // The URL pathname should be the URL without origin, query string, and hash.
    //  - https://developer.mozilla.org/en-US/docs/Web/API/URL/pathname
    (0, assert_1.assert)(pathnameResolved === pathnameResolved.split('?')[0].split('#')[0]);
    return { origin, pathnameResolved };
}
function assertUsageBaseServer(baseServer, usageErrorMessagePrefix = '') {
    (0, assert_1.assertUsage)(!baseServer.startsWith('http'), usageErrorMessagePrefix +
        '`base` is not allowed to start with `http`. Consider using `baseAssets` instead, see https://vite-plugin-ssr.com/base-url');
    (0, assert_1.assertUsage)(baseServer.startsWith('/'), usageErrorMessagePrefix + 'Wrong `base` value `' + baseServer + '`; `base` should start with `/`.');
    (0, assert_1.assert)(isBaseServer(baseServer));
}
exports.assertUsageBaseServer = assertUsageBaseServer;
function assertPathname(urlPathname) {
    (0, assert_1.assert)(urlPathname.startsWith('/'));
    (0, assert_1.assert)(!urlPathname.includes('?'));
    (0, assert_1.assert)(!urlPathname.includes('#'));
}
function analyzeBaseServer(urlPathnameWithBase, baseServer) {
    assertPathname(urlPathnameWithBase);
    (0, assert_1.assert)(isBaseServer(baseServer));
    // Mutable
    let urlPathname = urlPathnameWithBase;
    (0, assert_1.assert)(urlPathname.startsWith('/'));
    (0, assert_1.assert)(baseServer.startsWith('/'));
    if (baseServer === '/') {
        const pathname = urlPathnameWithBase;
        return { pathname, hasBaseServer: true };
    }
    // Support `url === '/some-base-url' && baseServer === '/some-base-url/'`
    let baseServerNormalized = baseServer;
    if (baseServer.endsWith('/') && urlPathname === (0, slice_1.slice)(baseServer, 0, -1)) {
        baseServerNormalized = (0, slice_1.slice)(baseServer, 0, -1);
        (0, assert_1.assert)(urlPathname === baseServerNormalized);
    }
    if (!urlPathname.startsWith(baseServerNormalized)) {
        const pathname = urlPathnameWithBase;
        return { pathname, hasBaseServer: false };
    }
    (0, assert_1.assert)(urlPathname.startsWith('/') || urlPathname.startsWith('http'));
    (0, assert_1.assert)(urlPathname.startsWith(baseServerNormalized));
    urlPathname = urlPathname.slice(baseServerNormalized.length);
    if (!urlPathname.startsWith('/'))
        urlPathname = '/' + urlPathname;
    (0, assert_1.assert)(urlPathname.startsWith('/'));
    return { pathname: urlPathname, hasBaseServer: true };
}
function prependBase(url, baseServer) {
    if (baseServer.startsWith('http')) {
        const baseAssets = baseServer;
        const baseAssetsNormalized = normalizeBaseAssets(baseAssets);
        (0, assert_1.assert)(!baseAssetsNormalized.endsWith('/'));
        (0, assert_1.assert)(url.startsWith('/'));
        return `${baseAssetsNormalized}${url}`;
    }
    (0, assert_1.assert)(isBaseServer(baseServer));
    const baseServerNormalized = normalizeBaseServer(baseServer);
    if (baseServerNormalized === '/')
        return url;
    (0, assert_1.assert)(!baseServerNormalized.endsWith('/'));
    (0, assert_1.assert)(url.startsWith('/'));
    return `${baseServerNormalized}${url}`;
}
exports.prependBase = prependBase;
function normalizeBaseServer(baseServer) {
    let baseServerNormalized = baseServer;
    if (baseServerNormalized.endsWith('/') && baseServerNormalized !== '/') {
        baseServerNormalized = (0, slice_1.slice)(baseServerNormalized, 0, -1);
    }
    // We can and should expect `baseServer` to not contain `/` doublets.
    (0, assert_1.assert)(!baseServerNormalized.endsWith('/') || baseServerNormalized === '/');
    return baseServerNormalized;
}
exports.normalizeBaseServer = normalizeBaseServer;
function isBaseServer(baseServer) {
    return baseServer.startsWith('/');
}
exports.isBaseServer = isBaseServer;
function isBaseAssets(base) {
    return base.startsWith('/') || base.startsWith('http://') || base.startsWith('https://');
}
exports.isBaseAssets = isBaseAssets;
function normalizeBaseAssets(baseAssets) {
    let baseAssetsNormalized = baseAssets;
    if (baseAssetsNormalized.endsWith('/')) {
        baseAssetsNormalized = (0, slice_1.slice)(baseAssetsNormalized, 0, -1);
    }
    (0, assert_1.assert)(!baseAssetsNormalized.endsWith('/'));
    return baseAssetsNormalized;
}
