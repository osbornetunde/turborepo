export { assert };
export { assertUsage };
export { assertWarning };
export { assertInfo };
export { getProjectError };
export { logPrefix };
export { addOnBeforeLogHook };
import { createErrorWithCleanStackTrace } from './createErrorWithCleanStackTrace';
import { getGlobalObject } from './getGlobalObject';
import { projectInfo } from './projectInfo';
const globalObject = getGlobalObject('assert.ts', {
    alreadyLogged: new Set()
});
const logPrefix = `[${projectInfo.npmPackageName}@${projectInfo.projectVersion}]`;
const internalErrorPrefix = `${logPrefix}[Bug]`;
const usageErrorPrefix = `${logPrefix}[Wrong Usage]`;
const warningPrefix = `${logPrefix}[Warning]`;
const infoPrefix = `${logPrefix}[Info]`;
const numberOfStackTraceLinesToRemove = 2;
function assert(condition, debugInfo) {
    var _a;
    if (condition) {
        return;
    }
    const debugStr = (() => {
        if (!debugInfo) {
            return null;
        }
        const debugInfoSerialized = typeof debugInfo === 'string' ? debugInfo : '`' + JSON.stringify(debugInfo) + '`';
        return `Debug info (this is for the ${projectInfo.projectName} maintainers; you can ignore this): ${debugInfoSerialized}`;
    })();
    const internalError = createErrorWithCleanStackTrace([
        `${internalErrorPrefix} You stumbled upon a bug in ${projectInfo.projectName}'s source code.`,
        `Go to ${projectInfo.githubRepository}/issues/new and copy-paste this error. (The error's stack trace is usually enough to fix the problem).`,
        'A maintainer will fix the bug (usually under 24 hours).',
        `Don't hesitate to reach out as it makes ${projectInfo.projectName} more robust.`,
        debugStr
    ]
        .filter(Boolean)
        .join(' '), numberOfStackTraceLinesToRemove);
    (_a = globalObject.onBeforeLog) === null || _a === void 0 ? void 0 : _a.call(globalObject);
    throw internalError;
}
function assertUsage(condition, errorMessage) {
    var _a;
    if (condition) {
        return;
    }
    const whiteSpace = errorMessage.startsWith('[') ? '' : ' ';
    const errMsg = `${usageErrorPrefix}${whiteSpace}${errorMessage}`;
    const usageError = createErrorWithCleanStackTrace(errMsg, numberOfStackTraceLinesToRemove);
    (_a = globalObject.onBeforeLog) === null || _a === void 0 ? void 0 : _a.call(globalObject);
    throw usageError;
}
function getProjectError(errorMessage) {
    const sep = errorMessage.startsWith('[') ? '' : ' ';
    const pluginError = createErrorWithCleanStackTrace(`${logPrefix}${sep}${errorMessage}`, numberOfStackTraceLinesToRemove);
    return pluginError;
}
function assertWarning(condition, errorMessage, { onlyOnce = true, showStackTrace = false } = {}) {
    var _a;
    if (condition) {
        return;
    }
    const msg = `${warningPrefix} ${errorMessage}`;
    if (onlyOnce) {
        const { alreadyLogged } = globalObject;
        const key = onlyOnce === true ? msg : onlyOnce;
        if (alreadyLogged.has(key)) {
            return;
        }
        else {
            alreadyLogged.add(key);
        }
    }
    (_a = globalObject.onBeforeLog) === null || _a === void 0 ? void 0 : _a.call(globalObject);
    if (showStackTrace) {
        console.warn(new Error(msg));
    }
    else {
        console.warn(msg);
    }
}
function assertInfo(condition, errorMessage, { onlyOnce }) {
    var _a;
    if (condition) {
        return;
    }
    const msg = `${infoPrefix} ${errorMessage}`;
    if (onlyOnce) {
        const { alreadyLogged } = globalObject;
        const key = msg;
        if (alreadyLogged.has(key)) {
            return;
        }
        else {
            alreadyLogged.add(key);
        }
    }
    (_a = globalObject.onBeforeLog) === null || _a === void 0 ? void 0 : _a.call(globalObject);
    console.log(msg);
}
function addOnBeforeLogHook(onBeforeLog) {
    globalObject.onBeforeLog = onBeforeLog;
}
