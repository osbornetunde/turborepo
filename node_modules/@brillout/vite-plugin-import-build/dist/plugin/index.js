"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importBuild = void 0;
const utils_1 = require("./utils");
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const importBuildFileName_1 = require("../shared/importBuildFileName");
const findBuildEntry_1 = require("./findBuildEntry");
const debugLogs_1 = require("../shared/debugLogs");
const autoImporterFilePath = require.resolve('../autoImporter');
const configVersion = 1;
function importBuild(options) {
    let config;
    let isServerSide = false;
    return {
        name: `@brillout/vite-plugin-import-build:${options.libraryName}`,
        apply: (_, env) => env.command === 'build',
        configResolved(configUnprocessed) {
            isServerSide = (0, utils_1.viteIsSSR)(configUnprocessed);
            if (!isServerSide)
                return;
            config = resolveConfig(configUnprocessed, options);
        },
        buildStart() {
            if (!isServerSide)
                return;
            assertOnlyNewerVersions(config);
            resetAutoImporter();
        },
        async generateBundle(_rollupOptions, rollupBundle) {
            if (!isServerSide)
                return;
            const emitFile = this.emitFile.bind(this);
            await generateImporter(emitFile, rollupBundle, config);
        }
    };
}
exports.importBuild = importBuild;
function resolveConfig(configUnprocessed, options) {
    var _a;
    (0, utils_1.assert)((0, utils_1.viteIsSSR)(configUnprocessed));
    const data = (_a = configUnprocessed._vitePluginImportBuild) !== null && _a !== void 0 ? _a : {
        libraries: [],
        importerAlreadyGenerated: false,
        configVersion,
        disableAutoImporter: false
    };
    (0, utils_1.assert)(data.configVersion === 1);
    (0, utils_1.assert)(configVersion === 1);
    if (data.configVersion !== configVersion) {
        // We don't use this yet (IIRC configVersion never had another value than `1`)
        (0, utils_1.assert)(1 === 1 + 1);
        const otherLibrary = data.libraries[0];
        (0, utils_1.assert)(otherLibrary);
        (0, utils_1.assert)(otherLibrary.libraryName !== options.libraryName);
        throw new Error(`Conflict between ${options.libraryName} and ${otherLibrary.libraryName}. Update both to their latest version and try again.`);
    }
    data.libraries.push({
        getImporterCode: options.getImporterCode,
        libraryName: options.libraryName,
        vitePluginImportBuildVersion: utils_1.projectInfo.projectVersion
    });
    (0, utils_1.objectAssign)(configUnprocessed, {
        _vitePluginImportBuild: data
    });
    return configUnprocessed;
}
async function generateImporter(emitFile, rollupBundle, config) {
    // Let the newest vite-plugin-import-build version generate autoImporter.js
    if (isUsingOlderVitePluginImportBuildVersion(config))
        return;
    if (config._vitePluginImportBuild.importerAlreadyGenerated)
        return;
    config._vitePluginImportBuild.importerAlreadyGenerated = true;
    (0, utils_1.assert)((0, utils_1.viteIsSSR)(config)); // rollupBundle should be the server-side one
    const source = config._vitePluginImportBuild.libraries
        .map(({ getImporterCode }) => getImporterCode({
        findBuildEntry: (entryName) => (0, findBuildEntry_1.findBuildEntry)(entryName, rollupBundle, config)
    }))
        .join('\n');
    emitFile({
        fileName: importBuildFileName_1.importBuildFileName,
        type: 'asset',
        source
    });
    setAutoImporter(config);
}
function setAutoImporter(config) {
    if (autoImporterIsDisabled(config))
        return;
    const { distServerPathRelative, distServerPathAbsolute } = getDistServerPathRelative(config);
    const importBuildFilePathRelative = path_1.default.posix.join(distServerPathRelative, importBuildFileName_1.importBuildFileName);
    const importBuildFilePathAbsolute = path_1.default.posix.join(distServerPathAbsolute, importBuildFileName_1.importBuildFileName);
    const { root } = config;
    (0, utils_1.assertPosixPath)(root);
    (0, fs_1.writeFileSync)(autoImporterFilePath, [
        "exports.status = 'SET';",
        `exports.loadImportBuild = () => { require(${JSON.stringify(importBuildFilePathRelative)}) };`,
        'exports.paths = {',
        `  autoImporterFilePathOriginal: ${JSON.stringify(autoImporterFilePath)},`,
        '  autoImporterFileDirActual: (() => { try { return __dirname } catch { return null } })(),',
        `  importBuildFilePathRelative: ${JSON.stringify(importBuildFilePathRelative)},`,
        `  importBuildFilePathOriginal: ${JSON.stringify(importBuildFilePathAbsolute)},`,
        `  importBuildFilePathResolved: () => require.resolve(${JSON.stringify(importBuildFilePathRelative)}),`,
        '};',
        // Support old vite-plugin-import-build@0.1.12 version, which is needed e.g. if user uses a Telefunc version using 0.1.12 while using a VPS version using 0.2.0
        `exports.load = exports.loadImportBuild;`,
        ''
    ].join('\n'));
}
function resetAutoImporter() {
    try {
        (0, fs_1.writeFileSync)(autoImporterFilePath, ["exports.status = 'UNSET';", ''].join('\n'));
    }
    catch (_a) { }
}
function autoImporterIsDisabled(config) {
    var _a;
    return (_a = config._vitePluginImportBuild.disableAutoImporter) !== null && _a !== void 0 ? _a : (0, utils_1.isYarnPnP)();
}
function isUsingOlderVitePluginImportBuildVersion(config) {
    return config._vitePluginImportBuild.libraries.some((library) => {
        if (!library.vitePluginImportBuildVersion)
            return false;
        return isHigherVersion(library.vitePluginImportBuildVersion, utils_1.projectInfo.projectVersion);
    });
}
function isHigherVersion(semver1, semver2) {
    const semver1Parts = parseSemver(semver1);
    const semver2Parts = parseSemver(semver2);
    for (let i = 0; i <= semver1Parts.length - 1; i++) {
        if (semver1Parts[i] === semver2Parts[i])
            continue;
        return semver1Parts[i] > semver2Parts[i];
    }
    return false;
}
function parseSemver(semver) {
    (0, utils_1.assert)(/^[0-9\.]+$/.test(semver));
    const parts = semver.split('.');
    (0, utils_1.assert)(parts.length === 3);
    return parts.map((n) => parseInt(n, 10));
}
function getDistServerPathRelative(config) {
    (0, utils_1.assert)((0, utils_1.viteIsSSR)(config));
    const { root } = config;
    (0, utils_1.assertPosixPath)(root);
    (0, utils_1.assert)((0, utils_1.isAbsolutePath)(root));
    const importerDir = getImporterDir();
    const rootRelative = path_1.default.posix.relative(importerDir, root); // To `require()` an absolute path doesn't seem to work on Vercel
    let { outDir } = config.build;
    // SvelteKit doesn't set config.build.outDir to a posix path
    outDir = (0, utils_1.toPosixPath)(outDir);
    if ((0, utils_1.isAbsolutePath)(outDir)) {
        outDir = path_1.default.posix.relative(root, outDir);
        (0, utils_1.assert)(!(0, utils_1.isAbsolutePath)(outDir));
    }
    const distServerPathRelative = path_1.default.posix.join(rootRelative, outDir);
    const distServerPathAbsolute = path_1.default.posix.join(root, outDir);
    (0, debugLogs_1.debugLogsBuildtime)({ importerDir, root, rootRelative, outDir, distServerPathRelative, distServerPathAbsolute });
    return { distServerPathRelative, distServerPathAbsolute };
}
function getImporterDir() {
    const currentDir = (0, utils_1.toPosixPath)(__dirname + (() => '')()); // trick to avoid `@vercel/ncc` to glob import
    return path_1.default.posix.join(currentDir, '..');
}
function assertOnlyNewerVersions(config) {
    if (!('vitePluginDistImporter' in config)) {
        return;
    }
    const dataOld = config.vitePluginDistImporter;
    const libName = dataOld.libraries[0].libraryName;
    (0, utils_1.assert)(libName);
    // We purposely use `throw new Error()` instead of assertUsage()
    throw new Error(`update ${libName} to its latest version and try again`);
}
